package usecase

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i gitlab.ozon.dev/bagdatov/homework-2/game-master/usecase.Parser -o ./parser_mock_test.go -n ParserMock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"gitlab.ozon.dev/bagdatov/homework-2/game-master/models"
)

// ParserMock implements Parser
type ParserMock struct {
	t minimock.Tester

	funcQuestion          func(ctx context.Context, tour string, num int64) (q1 models.Question, err error)
	inspectFuncQuestion   func(ctx context.Context, tour string, num int64)
	afterQuestionCounter  uint64
	beforeQuestionCounter uint64
	QuestionMock          mParserMockQuestion

	funcRoot          func(ctx context.Context) (t1 models.Tournament, err error)
	inspectFuncRoot   func(ctx context.Context)
	afterRootCounter  uint64
	beforeRootCounter uint64
	RootMock          mParserMockRoot

	funcTour          func(ctx context.Context, name string) (t1 models.Tour, err error)
	inspectFuncTour   func(ctx context.Context, name string)
	afterTourCounter  uint64
	beforeTourCounter uint64
	TourMock          mParserMockTour

	funcTournament          func(ctx context.Context, name string) (t1 models.Tournament, err error)
	inspectFuncTournament   func(ctx context.Context, name string)
	afterTournamentCounter  uint64
	beforeTournamentCounter uint64
	TournamentMock          mParserMockTournament
}

// NewParserMock returns a mock for Parser
func NewParserMock(t minimock.Tester) *ParserMock {
	m := &ParserMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.QuestionMock = mParserMockQuestion{mock: m}
	m.QuestionMock.callArgs = []*ParserMockQuestionParams{}

	m.RootMock = mParserMockRoot{mock: m}
	m.RootMock.callArgs = []*ParserMockRootParams{}

	m.TourMock = mParserMockTour{mock: m}
	m.TourMock.callArgs = []*ParserMockTourParams{}

	m.TournamentMock = mParserMockTournament{mock: m}
	m.TournamentMock.callArgs = []*ParserMockTournamentParams{}

	return m
}

type mParserMockQuestion struct {
	mock               *ParserMock
	defaultExpectation *ParserMockQuestionExpectation
	expectations       []*ParserMockQuestionExpectation

	callArgs []*ParserMockQuestionParams
	mutex    sync.RWMutex
}

// ParserMockQuestionExpectation specifies expectation struct of the Parser.Question
type ParserMockQuestionExpectation struct {
	mock    *ParserMock
	params  *ParserMockQuestionParams
	results *ParserMockQuestionResults
	Counter uint64
}

// ParserMockQuestionParams contains parameters of the Parser.Question
type ParserMockQuestionParams struct {
	ctx  context.Context
	tour string
	num  int64
}

// ParserMockQuestionResults contains results of the Parser.Question
type ParserMockQuestionResults struct {
	q1  models.Question
	err error
}

// Expect sets up expected params for Parser.Question
func (mmQuestion *mParserMockQuestion) Expect(ctx context.Context, tour string, num int64) *mParserMockQuestion {
	if mmQuestion.mock.funcQuestion != nil {
		mmQuestion.mock.t.Fatalf("ParserMock.Question mock is already set by Set")
	}

	if mmQuestion.defaultExpectation == nil {
		mmQuestion.defaultExpectation = &ParserMockQuestionExpectation{}
	}

	mmQuestion.defaultExpectation.params = &ParserMockQuestionParams{ctx, tour, num}
	for _, e := range mmQuestion.expectations {
		if minimock.Equal(e.params, mmQuestion.defaultExpectation.params) {
			mmQuestion.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmQuestion.defaultExpectation.params)
		}
	}

	return mmQuestion
}

// Inspect accepts an inspector function that has same arguments as the Parser.Question
func (mmQuestion *mParserMockQuestion) Inspect(f func(ctx context.Context, tour string, num int64)) *mParserMockQuestion {
	if mmQuestion.mock.inspectFuncQuestion != nil {
		mmQuestion.mock.t.Fatalf("Inspect function is already set for ParserMock.Question")
	}

	mmQuestion.mock.inspectFuncQuestion = f

	return mmQuestion
}

// Return sets up results that will be returned by Parser.Question
func (mmQuestion *mParserMockQuestion) Return(q1 models.Question, err error) *ParserMock {
	if mmQuestion.mock.funcQuestion != nil {
		mmQuestion.mock.t.Fatalf("ParserMock.Question mock is already set by Set")
	}

	if mmQuestion.defaultExpectation == nil {
		mmQuestion.defaultExpectation = &ParserMockQuestionExpectation{mock: mmQuestion.mock}
	}
	mmQuestion.defaultExpectation.results = &ParserMockQuestionResults{q1, err}
	return mmQuestion.mock
}

//Set uses given function f to mock the Parser.Question method
func (mmQuestion *mParserMockQuestion) Set(f func(ctx context.Context, tour string, num int64) (q1 models.Question, err error)) *ParserMock {
	if mmQuestion.defaultExpectation != nil {
		mmQuestion.mock.t.Fatalf("Default expectation is already set for the Parser.Question method")
	}

	if len(mmQuestion.expectations) > 0 {
		mmQuestion.mock.t.Fatalf("Some expectations are already set for the Parser.Question method")
	}

	mmQuestion.mock.funcQuestion = f
	return mmQuestion.mock
}

// When sets expectation for the Parser.Question which will trigger the result defined by the following
// Then helper
func (mmQuestion *mParserMockQuestion) When(ctx context.Context, tour string, num int64) *ParserMockQuestionExpectation {
	if mmQuestion.mock.funcQuestion != nil {
		mmQuestion.mock.t.Fatalf("ParserMock.Question mock is already set by Set")
	}

	expectation := &ParserMockQuestionExpectation{
		mock:   mmQuestion.mock,
		params: &ParserMockQuestionParams{ctx, tour, num},
	}
	mmQuestion.expectations = append(mmQuestion.expectations, expectation)
	return expectation
}

// Then sets up Parser.Question return parameters for the expectation previously defined by the When method
func (e *ParserMockQuestionExpectation) Then(q1 models.Question, err error) *ParserMock {
	e.results = &ParserMockQuestionResults{q1, err}
	return e.mock
}

// Question implements Parser
func (mmQuestion *ParserMock) Question(ctx context.Context, tour string, num int64) (q1 models.Question, err error) {
	mm_atomic.AddUint64(&mmQuestion.beforeQuestionCounter, 1)
	defer mm_atomic.AddUint64(&mmQuestion.afterQuestionCounter, 1)

	if mmQuestion.inspectFuncQuestion != nil {
		mmQuestion.inspectFuncQuestion(ctx, tour, num)
	}

	mm_params := &ParserMockQuestionParams{ctx, tour, num}

	// Record call args
	mmQuestion.QuestionMock.mutex.Lock()
	mmQuestion.QuestionMock.callArgs = append(mmQuestion.QuestionMock.callArgs, mm_params)
	mmQuestion.QuestionMock.mutex.Unlock()

	for _, e := range mmQuestion.QuestionMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.q1, e.results.err
		}
	}

	if mmQuestion.QuestionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmQuestion.QuestionMock.defaultExpectation.Counter, 1)
		mm_want := mmQuestion.QuestionMock.defaultExpectation.params
		mm_got := ParserMockQuestionParams{ctx, tour, num}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmQuestion.t.Errorf("ParserMock.Question got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmQuestion.QuestionMock.defaultExpectation.results
		if mm_results == nil {
			mmQuestion.t.Fatal("No results are set for the ParserMock.Question")
		}
		return (*mm_results).q1, (*mm_results).err
	}
	if mmQuestion.funcQuestion != nil {
		return mmQuestion.funcQuestion(ctx, tour, num)
	}
	mmQuestion.t.Fatalf("Unexpected call to ParserMock.Question. %v %v %v", ctx, tour, num)
	return
}

// QuestionAfterCounter returns a count of finished ParserMock.Question invocations
func (mmQuestion *ParserMock) QuestionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmQuestion.afterQuestionCounter)
}

// QuestionBeforeCounter returns a count of ParserMock.Question invocations
func (mmQuestion *ParserMock) QuestionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmQuestion.beforeQuestionCounter)
}

// Calls returns a list of arguments used in each call to ParserMock.Question.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmQuestion *mParserMockQuestion) Calls() []*ParserMockQuestionParams {
	mmQuestion.mutex.RLock()

	argCopy := make([]*ParserMockQuestionParams, len(mmQuestion.callArgs))
	copy(argCopy, mmQuestion.callArgs)

	mmQuestion.mutex.RUnlock()

	return argCopy
}

// MinimockQuestionDone returns true if the count of the Question invocations corresponds
// the number of defined expectations
func (m *ParserMock) MinimockQuestionDone() bool {
	for _, e := range m.QuestionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.QuestionMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterQuestionCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcQuestion != nil && mm_atomic.LoadUint64(&m.afterQuestionCounter) < 1 {
		return false
	}
	return true
}

// MinimockQuestionInspect logs each unmet expectation
func (m *ParserMock) MinimockQuestionInspect() {
	for _, e := range m.QuestionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ParserMock.Question with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.QuestionMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterQuestionCounter) < 1 {
		if m.QuestionMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ParserMock.Question")
		} else {
			m.t.Errorf("Expected call to ParserMock.Question with params: %#v", *m.QuestionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcQuestion != nil && mm_atomic.LoadUint64(&m.afterQuestionCounter) < 1 {
		m.t.Error("Expected call to ParserMock.Question")
	}
}

type mParserMockRoot struct {
	mock               *ParserMock
	defaultExpectation *ParserMockRootExpectation
	expectations       []*ParserMockRootExpectation

	callArgs []*ParserMockRootParams
	mutex    sync.RWMutex
}

// ParserMockRootExpectation specifies expectation struct of the Parser.Root
type ParserMockRootExpectation struct {
	mock    *ParserMock
	params  *ParserMockRootParams
	results *ParserMockRootResults
	Counter uint64
}

// ParserMockRootParams contains parameters of the Parser.Root
type ParserMockRootParams struct {
	ctx context.Context
}

// ParserMockRootResults contains results of the Parser.Root
type ParserMockRootResults struct {
	t1  models.Tournament
	err error
}

// Expect sets up expected params for Parser.Root
func (mmRoot *mParserMockRoot) Expect(ctx context.Context) *mParserMockRoot {
	if mmRoot.mock.funcRoot != nil {
		mmRoot.mock.t.Fatalf("ParserMock.Root mock is already set by Set")
	}

	if mmRoot.defaultExpectation == nil {
		mmRoot.defaultExpectation = &ParserMockRootExpectation{}
	}

	mmRoot.defaultExpectation.params = &ParserMockRootParams{ctx}
	for _, e := range mmRoot.expectations {
		if minimock.Equal(e.params, mmRoot.defaultExpectation.params) {
			mmRoot.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRoot.defaultExpectation.params)
		}
	}

	return mmRoot
}

// Inspect accepts an inspector function that has same arguments as the Parser.Root
func (mmRoot *mParserMockRoot) Inspect(f func(ctx context.Context)) *mParserMockRoot {
	if mmRoot.mock.inspectFuncRoot != nil {
		mmRoot.mock.t.Fatalf("Inspect function is already set for ParserMock.Root")
	}

	mmRoot.mock.inspectFuncRoot = f

	return mmRoot
}

// Return sets up results that will be returned by Parser.Root
func (mmRoot *mParserMockRoot) Return(t1 models.Tournament, err error) *ParserMock {
	if mmRoot.mock.funcRoot != nil {
		mmRoot.mock.t.Fatalf("ParserMock.Root mock is already set by Set")
	}

	if mmRoot.defaultExpectation == nil {
		mmRoot.defaultExpectation = &ParserMockRootExpectation{mock: mmRoot.mock}
	}
	mmRoot.defaultExpectation.results = &ParserMockRootResults{t1, err}
	return mmRoot.mock
}

//Set uses given function f to mock the Parser.Root method
func (mmRoot *mParserMockRoot) Set(f func(ctx context.Context) (t1 models.Tournament, err error)) *ParserMock {
	if mmRoot.defaultExpectation != nil {
		mmRoot.mock.t.Fatalf("Default expectation is already set for the Parser.Root method")
	}

	if len(mmRoot.expectations) > 0 {
		mmRoot.mock.t.Fatalf("Some expectations are already set for the Parser.Root method")
	}

	mmRoot.mock.funcRoot = f
	return mmRoot.mock
}

// When sets expectation for the Parser.Root which will trigger the result defined by the following
// Then helper
func (mmRoot *mParserMockRoot) When(ctx context.Context) *ParserMockRootExpectation {
	if mmRoot.mock.funcRoot != nil {
		mmRoot.mock.t.Fatalf("ParserMock.Root mock is already set by Set")
	}

	expectation := &ParserMockRootExpectation{
		mock:   mmRoot.mock,
		params: &ParserMockRootParams{ctx},
	}
	mmRoot.expectations = append(mmRoot.expectations, expectation)
	return expectation
}

// Then sets up Parser.Root return parameters for the expectation previously defined by the When method
func (e *ParserMockRootExpectation) Then(t1 models.Tournament, err error) *ParserMock {
	e.results = &ParserMockRootResults{t1, err}
	return e.mock
}

// Root implements Parser
func (mmRoot *ParserMock) Root(ctx context.Context) (t1 models.Tournament, err error) {
	mm_atomic.AddUint64(&mmRoot.beforeRootCounter, 1)
	defer mm_atomic.AddUint64(&mmRoot.afterRootCounter, 1)

	if mmRoot.inspectFuncRoot != nil {
		mmRoot.inspectFuncRoot(ctx)
	}

	mm_params := &ParserMockRootParams{ctx}

	// Record call args
	mmRoot.RootMock.mutex.Lock()
	mmRoot.RootMock.callArgs = append(mmRoot.RootMock.callArgs, mm_params)
	mmRoot.RootMock.mutex.Unlock()

	for _, e := range mmRoot.RootMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.t1, e.results.err
		}
	}

	if mmRoot.RootMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRoot.RootMock.defaultExpectation.Counter, 1)
		mm_want := mmRoot.RootMock.defaultExpectation.params
		mm_got := ParserMockRootParams{ctx}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRoot.t.Errorf("ParserMock.Root got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRoot.RootMock.defaultExpectation.results
		if mm_results == nil {
			mmRoot.t.Fatal("No results are set for the ParserMock.Root")
		}
		return (*mm_results).t1, (*mm_results).err
	}
	if mmRoot.funcRoot != nil {
		return mmRoot.funcRoot(ctx)
	}
	mmRoot.t.Fatalf("Unexpected call to ParserMock.Root. %v", ctx)
	return
}

// RootAfterCounter returns a count of finished ParserMock.Root invocations
func (mmRoot *ParserMock) RootAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRoot.afterRootCounter)
}

// RootBeforeCounter returns a count of ParserMock.Root invocations
func (mmRoot *ParserMock) RootBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRoot.beforeRootCounter)
}

// Calls returns a list of arguments used in each call to ParserMock.Root.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRoot *mParserMockRoot) Calls() []*ParserMockRootParams {
	mmRoot.mutex.RLock()

	argCopy := make([]*ParserMockRootParams, len(mmRoot.callArgs))
	copy(argCopy, mmRoot.callArgs)

	mmRoot.mutex.RUnlock()

	return argCopy
}

// MinimockRootDone returns true if the count of the Root invocations corresponds
// the number of defined expectations
func (m *ParserMock) MinimockRootDone() bool {
	for _, e := range m.RootMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RootMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRootCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRoot != nil && mm_atomic.LoadUint64(&m.afterRootCounter) < 1 {
		return false
	}
	return true
}

// MinimockRootInspect logs each unmet expectation
func (m *ParserMock) MinimockRootInspect() {
	for _, e := range m.RootMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ParserMock.Root with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RootMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRootCounter) < 1 {
		if m.RootMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ParserMock.Root")
		} else {
			m.t.Errorf("Expected call to ParserMock.Root with params: %#v", *m.RootMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRoot != nil && mm_atomic.LoadUint64(&m.afterRootCounter) < 1 {
		m.t.Error("Expected call to ParserMock.Root")
	}
}

type mParserMockTour struct {
	mock               *ParserMock
	defaultExpectation *ParserMockTourExpectation
	expectations       []*ParserMockTourExpectation

	callArgs []*ParserMockTourParams
	mutex    sync.RWMutex
}

// ParserMockTourExpectation specifies expectation struct of the Parser.Tour
type ParserMockTourExpectation struct {
	mock    *ParserMock
	params  *ParserMockTourParams
	results *ParserMockTourResults
	Counter uint64
}

// ParserMockTourParams contains parameters of the Parser.Tour
type ParserMockTourParams struct {
	ctx  context.Context
	name string
}

// ParserMockTourResults contains results of the Parser.Tour
type ParserMockTourResults struct {
	t1  models.Tour
	err error
}

// Expect sets up expected params for Parser.Tour
func (mmTour *mParserMockTour) Expect(ctx context.Context, name string) *mParserMockTour {
	if mmTour.mock.funcTour != nil {
		mmTour.mock.t.Fatalf("ParserMock.Tour mock is already set by Set")
	}

	if mmTour.defaultExpectation == nil {
		mmTour.defaultExpectation = &ParserMockTourExpectation{}
	}

	mmTour.defaultExpectation.params = &ParserMockTourParams{ctx, name}
	for _, e := range mmTour.expectations {
		if minimock.Equal(e.params, mmTour.defaultExpectation.params) {
			mmTour.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmTour.defaultExpectation.params)
		}
	}

	return mmTour
}

// Inspect accepts an inspector function that has same arguments as the Parser.Tour
func (mmTour *mParserMockTour) Inspect(f func(ctx context.Context, name string)) *mParserMockTour {
	if mmTour.mock.inspectFuncTour != nil {
		mmTour.mock.t.Fatalf("Inspect function is already set for ParserMock.Tour")
	}

	mmTour.mock.inspectFuncTour = f

	return mmTour
}

// Return sets up results that will be returned by Parser.Tour
func (mmTour *mParserMockTour) Return(t1 models.Tour, err error) *ParserMock {
	if mmTour.mock.funcTour != nil {
		mmTour.mock.t.Fatalf("ParserMock.Tour mock is already set by Set")
	}

	if mmTour.defaultExpectation == nil {
		mmTour.defaultExpectation = &ParserMockTourExpectation{mock: mmTour.mock}
	}
	mmTour.defaultExpectation.results = &ParserMockTourResults{t1, err}
	return mmTour.mock
}

//Set uses given function f to mock the Parser.Tour method
func (mmTour *mParserMockTour) Set(f func(ctx context.Context, name string) (t1 models.Tour, err error)) *ParserMock {
	if mmTour.defaultExpectation != nil {
		mmTour.mock.t.Fatalf("Default expectation is already set for the Parser.Tour method")
	}

	if len(mmTour.expectations) > 0 {
		mmTour.mock.t.Fatalf("Some expectations are already set for the Parser.Tour method")
	}

	mmTour.mock.funcTour = f
	return mmTour.mock
}

// When sets expectation for the Parser.Tour which will trigger the result defined by the following
// Then helper
func (mmTour *mParserMockTour) When(ctx context.Context, name string) *ParserMockTourExpectation {
	if mmTour.mock.funcTour != nil {
		mmTour.mock.t.Fatalf("ParserMock.Tour mock is already set by Set")
	}

	expectation := &ParserMockTourExpectation{
		mock:   mmTour.mock,
		params: &ParserMockTourParams{ctx, name},
	}
	mmTour.expectations = append(mmTour.expectations, expectation)
	return expectation
}

// Then sets up Parser.Tour return parameters for the expectation previously defined by the When method
func (e *ParserMockTourExpectation) Then(t1 models.Tour, err error) *ParserMock {
	e.results = &ParserMockTourResults{t1, err}
	return e.mock
}

// Tour implements Parser
func (mmTour *ParserMock) Tour(ctx context.Context, name string) (t1 models.Tour, err error) {
	mm_atomic.AddUint64(&mmTour.beforeTourCounter, 1)
	defer mm_atomic.AddUint64(&mmTour.afterTourCounter, 1)

	if mmTour.inspectFuncTour != nil {
		mmTour.inspectFuncTour(ctx, name)
	}

	mm_params := &ParserMockTourParams{ctx, name}

	// Record call args
	mmTour.TourMock.mutex.Lock()
	mmTour.TourMock.callArgs = append(mmTour.TourMock.callArgs, mm_params)
	mmTour.TourMock.mutex.Unlock()

	for _, e := range mmTour.TourMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.t1, e.results.err
		}
	}

	if mmTour.TourMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmTour.TourMock.defaultExpectation.Counter, 1)
		mm_want := mmTour.TourMock.defaultExpectation.params
		mm_got := ParserMockTourParams{ctx, name}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmTour.t.Errorf("ParserMock.Tour got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmTour.TourMock.defaultExpectation.results
		if mm_results == nil {
			mmTour.t.Fatal("No results are set for the ParserMock.Tour")
		}
		return (*mm_results).t1, (*mm_results).err
	}
	if mmTour.funcTour != nil {
		return mmTour.funcTour(ctx, name)
	}
	mmTour.t.Fatalf("Unexpected call to ParserMock.Tour. %v %v", ctx, name)
	return
}

// TourAfterCounter returns a count of finished ParserMock.Tour invocations
func (mmTour *ParserMock) TourAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTour.afterTourCounter)
}

// TourBeforeCounter returns a count of ParserMock.Tour invocations
func (mmTour *ParserMock) TourBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTour.beforeTourCounter)
}

// Calls returns a list of arguments used in each call to ParserMock.Tour.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmTour *mParserMockTour) Calls() []*ParserMockTourParams {
	mmTour.mutex.RLock()

	argCopy := make([]*ParserMockTourParams, len(mmTour.callArgs))
	copy(argCopy, mmTour.callArgs)

	mmTour.mutex.RUnlock()

	return argCopy
}

// MinimockTourDone returns true if the count of the Tour invocations corresponds
// the number of defined expectations
func (m *ParserMock) MinimockTourDone() bool {
	for _, e := range m.TourMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.TourMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterTourCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTour != nil && mm_atomic.LoadUint64(&m.afterTourCounter) < 1 {
		return false
	}
	return true
}

// MinimockTourInspect logs each unmet expectation
func (m *ParserMock) MinimockTourInspect() {
	for _, e := range m.TourMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ParserMock.Tour with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.TourMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterTourCounter) < 1 {
		if m.TourMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ParserMock.Tour")
		} else {
			m.t.Errorf("Expected call to ParserMock.Tour with params: %#v", *m.TourMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTour != nil && mm_atomic.LoadUint64(&m.afterTourCounter) < 1 {
		m.t.Error("Expected call to ParserMock.Tour")
	}
}

type mParserMockTournament struct {
	mock               *ParserMock
	defaultExpectation *ParserMockTournamentExpectation
	expectations       []*ParserMockTournamentExpectation

	callArgs []*ParserMockTournamentParams
	mutex    sync.RWMutex
}

// ParserMockTournamentExpectation specifies expectation struct of the Parser.Tournament
type ParserMockTournamentExpectation struct {
	mock    *ParserMock
	params  *ParserMockTournamentParams
	results *ParserMockTournamentResults
	Counter uint64
}

// ParserMockTournamentParams contains parameters of the Parser.Tournament
type ParserMockTournamentParams struct {
	ctx  context.Context
	name string
}

// ParserMockTournamentResults contains results of the Parser.Tournament
type ParserMockTournamentResults struct {
	t1  models.Tournament
	err error
}

// Expect sets up expected params for Parser.Tournament
func (mmTournament *mParserMockTournament) Expect(ctx context.Context, name string) *mParserMockTournament {
	if mmTournament.mock.funcTournament != nil {
		mmTournament.mock.t.Fatalf("ParserMock.Tournament mock is already set by Set")
	}

	if mmTournament.defaultExpectation == nil {
		mmTournament.defaultExpectation = &ParserMockTournamentExpectation{}
	}

	mmTournament.defaultExpectation.params = &ParserMockTournamentParams{ctx, name}
	for _, e := range mmTournament.expectations {
		if minimock.Equal(e.params, mmTournament.defaultExpectation.params) {
			mmTournament.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmTournament.defaultExpectation.params)
		}
	}

	return mmTournament
}

// Inspect accepts an inspector function that has same arguments as the Parser.Tournament
func (mmTournament *mParserMockTournament) Inspect(f func(ctx context.Context, name string)) *mParserMockTournament {
	if mmTournament.mock.inspectFuncTournament != nil {
		mmTournament.mock.t.Fatalf("Inspect function is already set for ParserMock.Tournament")
	}

	mmTournament.mock.inspectFuncTournament = f

	return mmTournament
}

// Return sets up results that will be returned by Parser.Tournament
func (mmTournament *mParserMockTournament) Return(t1 models.Tournament, err error) *ParserMock {
	if mmTournament.mock.funcTournament != nil {
		mmTournament.mock.t.Fatalf("ParserMock.Tournament mock is already set by Set")
	}

	if mmTournament.defaultExpectation == nil {
		mmTournament.defaultExpectation = &ParserMockTournamentExpectation{mock: mmTournament.mock}
	}
	mmTournament.defaultExpectation.results = &ParserMockTournamentResults{t1, err}
	return mmTournament.mock
}

//Set uses given function f to mock the Parser.Tournament method
func (mmTournament *mParserMockTournament) Set(f func(ctx context.Context, name string) (t1 models.Tournament, err error)) *ParserMock {
	if mmTournament.defaultExpectation != nil {
		mmTournament.mock.t.Fatalf("Default expectation is already set for the Parser.Tournament method")
	}

	if len(mmTournament.expectations) > 0 {
		mmTournament.mock.t.Fatalf("Some expectations are already set for the Parser.Tournament method")
	}

	mmTournament.mock.funcTournament = f
	return mmTournament.mock
}

// When sets expectation for the Parser.Tournament which will trigger the result defined by the following
// Then helper
func (mmTournament *mParserMockTournament) When(ctx context.Context, name string) *ParserMockTournamentExpectation {
	if mmTournament.mock.funcTournament != nil {
		mmTournament.mock.t.Fatalf("ParserMock.Tournament mock is already set by Set")
	}

	expectation := &ParserMockTournamentExpectation{
		mock:   mmTournament.mock,
		params: &ParserMockTournamentParams{ctx, name},
	}
	mmTournament.expectations = append(mmTournament.expectations, expectation)
	return expectation
}

// Then sets up Parser.Tournament return parameters for the expectation previously defined by the When method
func (e *ParserMockTournamentExpectation) Then(t1 models.Tournament, err error) *ParserMock {
	e.results = &ParserMockTournamentResults{t1, err}
	return e.mock
}

// Tournament implements Parser
func (mmTournament *ParserMock) Tournament(ctx context.Context, name string) (t1 models.Tournament, err error) {
	mm_atomic.AddUint64(&mmTournament.beforeTournamentCounter, 1)
	defer mm_atomic.AddUint64(&mmTournament.afterTournamentCounter, 1)

	if mmTournament.inspectFuncTournament != nil {
		mmTournament.inspectFuncTournament(ctx, name)
	}

	mm_params := &ParserMockTournamentParams{ctx, name}

	// Record call args
	mmTournament.TournamentMock.mutex.Lock()
	mmTournament.TournamentMock.callArgs = append(mmTournament.TournamentMock.callArgs, mm_params)
	mmTournament.TournamentMock.mutex.Unlock()

	for _, e := range mmTournament.TournamentMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.t1, e.results.err
		}
	}

	if mmTournament.TournamentMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmTournament.TournamentMock.defaultExpectation.Counter, 1)
		mm_want := mmTournament.TournamentMock.defaultExpectation.params
		mm_got := ParserMockTournamentParams{ctx, name}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmTournament.t.Errorf("ParserMock.Tournament got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmTournament.TournamentMock.defaultExpectation.results
		if mm_results == nil {
			mmTournament.t.Fatal("No results are set for the ParserMock.Tournament")
		}
		return (*mm_results).t1, (*mm_results).err
	}
	if mmTournament.funcTournament != nil {
		return mmTournament.funcTournament(ctx, name)
	}
	mmTournament.t.Fatalf("Unexpected call to ParserMock.Tournament. %v %v", ctx, name)
	return
}

// TournamentAfterCounter returns a count of finished ParserMock.Tournament invocations
func (mmTournament *ParserMock) TournamentAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTournament.afterTournamentCounter)
}

// TournamentBeforeCounter returns a count of ParserMock.Tournament invocations
func (mmTournament *ParserMock) TournamentBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTournament.beforeTournamentCounter)
}

// Calls returns a list of arguments used in each call to ParserMock.Tournament.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmTournament *mParserMockTournament) Calls() []*ParserMockTournamentParams {
	mmTournament.mutex.RLock()

	argCopy := make([]*ParserMockTournamentParams, len(mmTournament.callArgs))
	copy(argCopy, mmTournament.callArgs)

	mmTournament.mutex.RUnlock()

	return argCopy
}

// MinimockTournamentDone returns true if the count of the Tournament invocations corresponds
// the number of defined expectations
func (m *ParserMock) MinimockTournamentDone() bool {
	for _, e := range m.TournamentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.TournamentMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterTournamentCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTournament != nil && mm_atomic.LoadUint64(&m.afterTournamentCounter) < 1 {
		return false
	}
	return true
}

// MinimockTournamentInspect logs each unmet expectation
func (m *ParserMock) MinimockTournamentInspect() {
	for _, e := range m.TournamentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ParserMock.Tournament with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.TournamentMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterTournamentCounter) < 1 {
		if m.TournamentMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ParserMock.Tournament")
		} else {
			m.t.Errorf("Expected call to ParserMock.Tournament with params: %#v", *m.TournamentMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTournament != nil && mm_atomic.LoadUint64(&m.afterTournamentCounter) < 1 {
		m.t.Error("Expected call to ParserMock.Tournament")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ParserMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockQuestionInspect()

		m.MinimockRootInspect()

		m.MinimockTourInspect()

		m.MinimockTournamentInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ParserMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ParserMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockQuestionDone() &&
		m.MinimockRootDone() &&
		m.MinimockTourDone() &&
		m.MinimockTournamentDone()
}
