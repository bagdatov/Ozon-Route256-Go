package usecase

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i gitlab.ozon.dev/bagdatov/homework-2/game-master/usecase.Game -o ./game_mock_test.go -n GameMock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"gitlab.ozon.dev/bagdatov/homework-2/game-master/models"
)

// GameMock implements Game
type GameMock struct {
	t minimock.Tester

	funcBegin          func(ctx context.Context, tournamentName string, chatID int64) (questions []int64, err error)
	inspectFuncBegin   func(ctx context.Context, tournamentName string, chatID int64)
	afterBeginCounter  uint64
	beforeBeginCounter uint64
	BeginMock          mGameMockBegin

	funcFetchQuestion          func(ctx context.Context, questionID int64) (q1 models.Question, err error)
	inspectFuncFetchQuestion   func(ctx context.Context, questionID int64)
	afterFetchQuestionCounter  uint64
	beforeFetchQuestionCounter uint64
	FetchQuestionMock          mGameMockFetchQuestion

	funcFetchScore          func(ctx context.Context, chatID int64) (ua1 []models.User, err error)
	inspectFuncFetchScore   func(ctx context.Context, chatID int64)
	afterFetchScoreCounter  uint64
	beforeFetchScoreCounter uint64
	FetchScoreMock          mGameMockFetchScore

	funcFetchSessions          func(ctx context.Context, chatID int64) (sa1 []models.Session, err error)
	inspectFuncFetchSessions   func(ctx context.Context, chatID int64)
	afterFetchSessionsCounter  uint64
	beforeFetchSessionsCounter uint64
	FetchSessionsMock          mGameMockFetchSessions

	funcFindTournament          func(ctx context.Context, name string) (t1 models.Tournament, err error)
	inspectFuncFindTournament   func(ctx context.Context, name string)
	afterFindTournamentCounter  uint64
	beforeFindTournamentCounter uint64
	FindTournamentMock          mGameMockFindTournament

	funcFinishSession          func(ctx context.Context, chatID int64) (err error)
	inspectFuncFinishSession   func(ctx context.Context, chatID int64)
	afterFinishSessionCounter  uint64
	beforeFinishSessionCounter uint64
	FinishSessionMock          mGameMockFinishSession

	funcRandomTournaments          func(ctx context.Context) (ta1 []models.TourI, err error)
	inspectFuncRandomTournaments   func(ctx context.Context)
	afterRandomTournamentsCounter  uint64
	beforeRandomTournamentsCounter uint64
	RandomTournamentsMock          mGameMockRandomTournaments

	funcSubmitGuess          func(ctx context.Context, chatID int64, questionID int64, username string, guess string) (b1 bool, err error)
	inspectFuncSubmitGuess   func(ctx context.Context, chatID int64, questionID int64, username string, guess string)
	afterSubmitGuessCounter  uint64
	beforeSubmitGuessCounter uint64
	SubmitGuessMock          mGameMockSubmitGuess
}

// NewGameMock returns a mock for Game
func NewGameMock(t minimock.Tester) *GameMock {
	m := &GameMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.BeginMock = mGameMockBegin{mock: m}
	m.BeginMock.callArgs = []*GameMockBeginParams{}

	m.FetchQuestionMock = mGameMockFetchQuestion{mock: m}
	m.FetchQuestionMock.callArgs = []*GameMockFetchQuestionParams{}

	m.FetchScoreMock = mGameMockFetchScore{mock: m}
	m.FetchScoreMock.callArgs = []*GameMockFetchScoreParams{}

	m.FetchSessionsMock = mGameMockFetchSessions{mock: m}
	m.FetchSessionsMock.callArgs = []*GameMockFetchSessionsParams{}

	m.FindTournamentMock = mGameMockFindTournament{mock: m}
	m.FindTournamentMock.callArgs = []*GameMockFindTournamentParams{}

	m.FinishSessionMock = mGameMockFinishSession{mock: m}
	m.FinishSessionMock.callArgs = []*GameMockFinishSessionParams{}

	m.RandomTournamentsMock = mGameMockRandomTournaments{mock: m}
	m.RandomTournamentsMock.callArgs = []*GameMockRandomTournamentsParams{}

	m.SubmitGuessMock = mGameMockSubmitGuess{mock: m}
	m.SubmitGuessMock.callArgs = []*GameMockSubmitGuessParams{}

	return m
}

type mGameMockBegin struct {
	mock               *GameMock
	defaultExpectation *GameMockBeginExpectation
	expectations       []*GameMockBeginExpectation

	callArgs []*GameMockBeginParams
	mutex    sync.RWMutex
}

// GameMockBeginExpectation specifies expectation struct of the Game.Begin
type GameMockBeginExpectation struct {
	mock    *GameMock
	params  *GameMockBeginParams
	results *GameMockBeginResults
	Counter uint64
}

// GameMockBeginParams contains parameters of the Game.Begin
type GameMockBeginParams struct {
	ctx            context.Context
	tournamentName string
	chatID         int64
}

// GameMockBeginResults contains results of the Game.Begin
type GameMockBeginResults struct {
	questions []int64
	err       error
}

// Expect sets up expected params for Game.Begin
func (mmBegin *mGameMockBegin) Expect(ctx context.Context, tournamentName string, chatID int64) *mGameMockBegin {
	if mmBegin.mock.funcBegin != nil {
		mmBegin.mock.t.Fatalf("GameMock.Begin mock is already set by Set")
	}

	if mmBegin.defaultExpectation == nil {
		mmBegin.defaultExpectation = &GameMockBeginExpectation{}
	}

	mmBegin.defaultExpectation.params = &GameMockBeginParams{ctx, tournamentName, chatID}
	for _, e := range mmBegin.expectations {
		if minimock.Equal(e.params, mmBegin.defaultExpectation.params) {
			mmBegin.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmBegin.defaultExpectation.params)
		}
	}

	return mmBegin
}

// Inspect accepts an inspector function that has same arguments as the Game.Begin
func (mmBegin *mGameMockBegin) Inspect(f func(ctx context.Context, tournamentName string, chatID int64)) *mGameMockBegin {
	if mmBegin.mock.inspectFuncBegin != nil {
		mmBegin.mock.t.Fatalf("Inspect function is already set for GameMock.Begin")
	}

	mmBegin.mock.inspectFuncBegin = f

	return mmBegin
}

// Return sets up results that will be returned by Game.Begin
func (mmBegin *mGameMockBegin) Return(questions []int64, err error) *GameMock {
	if mmBegin.mock.funcBegin != nil {
		mmBegin.mock.t.Fatalf("GameMock.Begin mock is already set by Set")
	}

	if mmBegin.defaultExpectation == nil {
		mmBegin.defaultExpectation = &GameMockBeginExpectation{mock: mmBegin.mock}
	}
	mmBegin.defaultExpectation.results = &GameMockBeginResults{questions, err}
	return mmBegin.mock
}

//Set uses given function f to mock the Game.Begin method
func (mmBegin *mGameMockBegin) Set(f func(ctx context.Context, tournamentName string, chatID int64) (questions []int64, err error)) *GameMock {
	if mmBegin.defaultExpectation != nil {
		mmBegin.mock.t.Fatalf("Default expectation is already set for the Game.Begin method")
	}

	if len(mmBegin.expectations) > 0 {
		mmBegin.mock.t.Fatalf("Some expectations are already set for the Game.Begin method")
	}

	mmBegin.mock.funcBegin = f
	return mmBegin.mock
}

// When sets expectation for the Game.Begin which will trigger the result defined by the following
// Then helper
func (mmBegin *mGameMockBegin) When(ctx context.Context, tournamentName string, chatID int64) *GameMockBeginExpectation {
	if mmBegin.mock.funcBegin != nil {
		mmBegin.mock.t.Fatalf("GameMock.Begin mock is already set by Set")
	}

	expectation := &GameMockBeginExpectation{
		mock:   mmBegin.mock,
		params: &GameMockBeginParams{ctx, tournamentName, chatID},
	}
	mmBegin.expectations = append(mmBegin.expectations, expectation)
	return expectation
}

// Then sets up Game.Begin return parameters for the expectation previously defined by the When method
func (e *GameMockBeginExpectation) Then(questions []int64, err error) *GameMock {
	e.results = &GameMockBeginResults{questions, err}
	return e.mock
}

// Begin implements Game
func (mmBegin *GameMock) Begin(ctx context.Context, tournamentName string, chatID int64) (questions []int64, err error) {
	mm_atomic.AddUint64(&mmBegin.beforeBeginCounter, 1)
	defer mm_atomic.AddUint64(&mmBegin.afterBeginCounter, 1)

	if mmBegin.inspectFuncBegin != nil {
		mmBegin.inspectFuncBegin(ctx, tournamentName, chatID)
	}

	mm_params := &GameMockBeginParams{ctx, tournamentName, chatID}

	// Record call args
	mmBegin.BeginMock.mutex.Lock()
	mmBegin.BeginMock.callArgs = append(mmBegin.BeginMock.callArgs, mm_params)
	mmBegin.BeginMock.mutex.Unlock()

	for _, e := range mmBegin.BeginMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.questions, e.results.err
		}
	}

	if mmBegin.BeginMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmBegin.BeginMock.defaultExpectation.Counter, 1)
		mm_want := mmBegin.BeginMock.defaultExpectation.params
		mm_got := GameMockBeginParams{ctx, tournamentName, chatID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmBegin.t.Errorf("GameMock.Begin got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmBegin.BeginMock.defaultExpectation.results
		if mm_results == nil {
			mmBegin.t.Fatal("No results are set for the GameMock.Begin")
		}
		return (*mm_results).questions, (*mm_results).err
	}
	if mmBegin.funcBegin != nil {
		return mmBegin.funcBegin(ctx, tournamentName, chatID)
	}
	mmBegin.t.Fatalf("Unexpected call to GameMock.Begin. %v %v %v", ctx, tournamentName, chatID)
	return
}

// BeginAfterCounter returns a count of finished GameMock.Begin invocations
func (mmBegin *GameMock) BeginAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBegin.afterBeginCounter)
}

// BeginBeforeCounter returns a count of GameMock.Begin invocations
func (mmBegin *GameMock) BeginBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBegin.beforeBeginCounter)
}

// Calls returns a list of arguments used in each call to GameMock.Begin.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmBegin *mGameMockBegin) Calls() []*GameMockBeginParams {
	mmBegin.mutex.RLock()

	argCopy := make([]*GameMockBeginParams, len(mmBegin.callArgs))
	copy(argCopy, mmBegin.callArgs)

	mmBegin.mutex.RUnlock()

	return argCopy
}

// MinimockBeginDone returns true if the count of the Begin invocations corresponds
// the number of defined expectations
func (m *GameMock) MinimockBeginDone() bool {
	for _, e := range m.BeginMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.BeginMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterBeginCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcBegin != nil && mm_atomic.LoadUint64(&m.afterBeginCounter) < 1 {
		return false
	}
	return true
}

// MinimockBeginInspect logs each unmet expectation
func (m *GameMock) MinimockBeginInspect() {
	for _, e := range m.BeginMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to GameMock.Begin with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.BeginMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterBeginCounter) < 1 {
		if m.BeginMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to GameMock.Begin")
		} else {
			m.t.Errorf("Expected call to GameMock.Begin with params: %#v", *m.BeginMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcBegin != nil && mm_atomic.LoadUint64(&m.afterBeginCounter) < 1 {
		m.t.Error("Expected call to GameMock.Begin")
	}
}

type mGameMockFetchQuestion struct {
	mock               *GameMock
	defaultExpectation *GameMockFetchQuestionExpectation
	expectations       []*GameMockFetchQuestionExpectation

	callArgs []*GameMockFetchQuestionParams
	mutex    sync.RWMutex
}

// GameMockFetchQuestionExpectation specifies expectation struct of the Game.FetchQuestion
type GameMockFetchQuestionExpectation struct {
	mock    *GameMock
	params  *GameMockFetchQuestionParams
	results *GameMockFetchQuestionResults
	Counter uint64
}

// GameMockFetchQuestionParams contains parameters of the Game.FetchQuestion
type GameMockFetchQuestionParams struct {
	ctx        context.Context
	questionID int64
}

// GameMockFetchQuestionResults contains results of the Game.FetchQuestion
type GameMockFetchQuestionResults struct {
	q1  models.Question
	err error
}

// Expect sets up expected params for Game.FetchQuestion
func (mmFetchQuestion *mGameMockFetchQuestion) Expect(ctx context.Context, questionID int64) *mGameMockFetchQuestion {
	if mmFetchQuestion.mock.funcFetchQuestion != nil {
		mmFetchQuestion.mock.t.Fatalf("GameMock.FetchQuestion mock is already set by Set")
	}

	if mmFetchQuestion.defaultExpectation == nil {
		mmFetchQuestion.defaultExpectation = &GameMockFetchQuestionExpectation{}
	}

	mmFetchQuestion.defaultExpectation.params = &GameMockFetchQuestionParams{ctx, questionID}
	for _, e := range mmFetchQuestion.expectations {
		if minimock.Equal(e.params, mmFetchQuestion.defaultExpectation.params) {
			mmFetchQuestion.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmFetchQuestion.defaultExpectation.params)
		}
	}

	return mmFetchQuestion
}

// Inspect accepts an inspector function that has same arguments as the Game.FetchQuestion
func (mmFetchQuestion *mGameMockFetchQuestion) Inspect(f func(ctx context.Context, questionID int64)) *mGameMockFetchQuestion {
	if mmFetchQuestion.mock.inspectFuncFetchQuestion != nil {
		mmFetchQuestion.mock.t.Fatalf("Inspect function is already set for GameMock.FetchQuestion")
	}

	mmFetchQuestion.mock.inspectFuncFetchQuestion = f

	return mmFetchQuestion
}

// Return sets up results that will be returned by Game.FetchQuestion
func (mmFetchQuestion *mGameMockFetchQuestion) Return(q1 models.Question, err error) *GameMock {
	if mmFetchQuestion.mock.funcFetchQuestion != nil {
		mmFetchQuestion.mock.t.Fatalf("GameMock.FetchQuestion mock is already set by Set")
	}

	if mmFetchQuestion.defaultExpectation == nil {
		mmFetchQuestion.defaultExpectation = &GameMockFetchQuestionExpectation{mock: mmFetchQuestion.mock}
	}
	mmFetchQuestion.defaultExpectation.results = &GameMockFetchQuestionResults{q1, err}
	return mmFetchQuestion.mock
}

//Set uses given function f to mock the Game.FetchQuestion method
func (mmFetchQuestion *mGameMockFetchQuestion) Set(f func(ctx context.Context, questionID int64) (q1 models.Question, err error)) *GameMock {
	if mmFetchQuestion.defaultExpectation != nil {
		mmFetchQuestion.mock.t.Fatalf("Default expectation is already set for the Game.FetchQuestion method")
	}

	if len(mmFetchQuestion.expectations) > 0 {
		mmFetchQuestion.mock.t.Fatalf("Some expectations are already set for the Game.FetchQuestion method")
	}

	mmFetchQuestion.mock.funcFetchQuestion = f
	return mmFetchQuestion.mock
}

// When sets expectation for the Game.FetchQuestion which will trigger the result defined by the following
// Then helper
func (mmFetchQuestion *mGameMockFetchQuestion) When(ctx context.Context, questionID int64) *GameMockFetchQuestionExpectation {
	if mmFetchQuestion.mock.funcFetchQuestion != nil {
		mmFetchQuestion.mock.t.Fatalf("GameMock.FetchQuestion mock is already set by Set")
	}

	expectation := &GameMockFetchQuestionExpectation{
		mock:   mmFetchQuestion.mock,
		params: &GameMockFetchQuestionParams{ctx, questionID},
	}
	mmFetchQuestion.expectations = append(mmFetchQuestion.expectations, expectation)
	return expectation
}

// Then sets up Game.FetchQuestion return parameters for the expectation previously defined by the When method
func (e *GameMockFetchQuestionExpectation) Then(q1 models.Question, err error) *GameMock {
	e.results = &GameMockFetchQuestionResults{q1, err}
	return e.mock
}

// FetchQuestion implements Game
func (mmFetchQuestion *GameMock) FetchQuestion(ctx context.Context, questionID int64) (q1 models.Question, err error) {
	mm_atomic.AddUint64(&mmFetchQuestion.beforeFetchQuestionCounter, 1)
	defer mm_atomic.AddUint64(&mmFetchQuestion.afterFetchQuestionCounter, 1)

	if mmFetchQuestion.inspectFuncFetchQuestion != nil {
		mmFetchQuestion.inspectFuncFetchQuestion(ctx, questionID)
	}

	mm_params := &GameMockFetchQuestionParams{ctx, questionID}

	// Record call args
	mmFetchQuestion.FetchQuestionMock.mutex.Lock()
	mmFetchQuestion.FetchQuestionMock.callArgs = append(mmFetchQuestion.FetchQuestionMock.callArgs, mm_params)
	mmFetchQuestion.FetchQuestionMock.mutex.Unlock()

	for _, e := range mmFetchQuestion.FetchQuestionMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.q1, e.results.err
		}
	}

	if mmFetchQuestion.FetchQuestionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFetchQuestion.FetchQuestionMock.defaultExpectation.Counter, 1)
		mm_want := mmFetchQuestion.FetchQuestionMock.defaultExpectation.params
		mm_got := GameMockFetchQuestionParams{ctx, questionID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmFetchQuestion.t.Errorf("GameMock.FetchQuestion got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmFetchQuestion.FetchQuestionMock.defaultExpectation.results
		if mm_results == nil {
			mmFetchQuestion.t.Fatal("No results are set for the GameMock.FetchQuestion")
		}
		return (*mm_results).q1, (*mm_results).err
	}
	if mmFetchQuestion.funcFetchQuestion != nil {
		return mmFetchQuestion.funcFetchQuestion(ctx, questionID)
	}
	mmFetchQuestion.t.Fatalf("Unexpected call to GameMock.FetchQuestion. %v %v", ctx, questionID)
	return
}

// FetchQuestionAfterCounter returns a count of finished GameMock.FetchQuestion invocations
func (mmFetchQuestion *GameMock) FetchQuestionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFetchQuestion.afterFetchQuestionCounter)
}

// FetchQuestionBeforeCounter returns a count of GameMock.FetchQuestion invocations
func (mmFetchQuestion *GameMock) FetchQuestionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFetchQuestion.beforeFetchQuestionCounter)
}

// Calls returns a list of arguments used in each call to GameMock.FetchQuestion.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmFetchQuestion *mGameMockFetchQuestion) Calls() []*GameMockFetchQuestionParams {
	mmFetchQuestion.mutex.RLock()

	argCopy := make([]*GameMockFetchQuestionParams, len(mmFetchQuestion.callArgs))
	copy(argCopy, mmFetchQuestion.callArgs)

	mmFetchQuestion.mutex.RUnlock()

	return argCopy
}

// MinimockFetchQuestionDone returns true if the count of the FetchQuestion invocations corresponds
// the number of defined expectations
func (m *GameMock) MinimockFetchQuestionDone() bool {
	for _, e := range m.FetchQuestionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FetchQuestionMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFetchQuestionCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFetchQuestion != nil && mm_atomic.LoadUint64(&m.afterFetchQuestionCounter) < 1 {
		return false
	}
	return true
}

// MinimockFetchQuestionInspect logs each unmet expectation
func (m *GameMock) MinimockFetchQuestionInspect() {
	for _, e := range m.FetchQuestionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to GameMock.FetchQuestion with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FetchQuestionMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFetchQuestionCounter) < 1 {
		if m.FetchQuestionMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to GameMock.FetchQuestion")
		} else {
			m.t.Errorf("Expected call to GameMock.FetchQuestion with params: %#v", *m.FetchQuestionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFetchQuestion != nil && mm_atomic.LoadUint64(&m.afterFetchQuestionCounter) < 1 {
		m.t.Error("Expected call to GameMock.FetchQuestion")
	}
}

type mGameMockFetchScore struct {
	mock               *GameMock
	defaultExpectation *GameMockFetchScoreExpectation
	expectations       []*GameMockFetchScoreExpectation

	callArgs []*GameMockFetchScoreParams
	mutex    sync.RWMutex
}

// GameMockFetchScoreExpectation specifies expectation struct of the Game.FetchScore
type GameMockFetchScoreExpectation struct {
	mock    *GameMock
	params  *GameMockFetchScoreParams
	results *GameMockFetchScoreResults
	Counter uint64
}

// GameMockFetchScoreParams contains parameters of the Game.FetchScore
type GameMockFetchScoreParams struct {
	ctx    context.Context
	chatID int64
}

// GameMockFetchScoreResults contains results of the Game.FetchScore
type GameMockFetchScoreResults struct {
	ua1 []models.User
	err error
}

// Expect sets up expected params for Game.FetchScore
func (mmFetchScore *mGameMockFetchScore) Expect(ctx context.Context, chatID int64) *mGameMockFetchScore {
	if mmFetchScore.mock.funcFetchScore != nil {
		mmFetchScore.mock.t.Fatalf("GameMock.FetchScore mock is already set by Set")
	}

	if mmFetchScore.defaultExpectation == nil {
		mmFetchScore.defaultExpectation = &GameMockFetchScoreExpectation{}
	}

	mmFetchScore.defaultExpectation.params = &GameMockFetchScoreParams{ctx, chatID}
	for _, e := range mmFetchScore.expectations {
		if minimock.Equal(e.params, mmFetchScore.defaultExpectation.params) {
			mmFetchScore.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmFetchScore.defaultExpectation.params)
		}
	}

	return mmFetchScore
}

// Inspect accepts an inspector function that has same arguments as the Game.FetchScore
func (mmFetchScore *mGameMockFetchScore) Inspect(f func(ctx context.Context, chatID int64)) *mGameMockFetchScore {
	if mmFetchScore.mock.inspectFuncFetchScore != nil {
		mmFetchScore.mock.t.Fatalf("Inspect function is already set for GameMock.FetchScore")
	}

	mmFetchScore.mock.inspectFuncFetchScore = f

	return mmFetchScore
}

// Return sets up results that will be returned by Game.FetchScore
func (mmFetchScore *mGameMockFetchScore) Return(ua1 []models.User, err error) *GameMock {
	if mmFetchScore.mock.funcFetchScore != nil {
		mmFetchScore.mock.t.Fatalf("GameMock.FetchScore mock is already set by Set")
	}

	if mmFetchScore.defaultExpectation == nil {
		mmFetchScore.defaultExpectation = &GameMockFetchScoreExpectation{mock: mmFetchScore.mock}
	}
	mmFetchScore.defaultExpectation.results = &GameMockFetchScoreResults{ua1, err}
	return mmFetchScore.mock
}

//Set uses given function f to mock the Game.FetchScore method
func (mmFetchScore *mGameMockFetchScore) Set(f func(ctx context.Context, chatID int64) (ua1 []models.User, err error)) *GameMock {
	if mmFetchScore.defaultExpectation != nil {
		mmFetchScore.mock.t.Fatalf("Default expectation is already set for the Game.FetchScore method")
	}

	if len(mmFetchScore.expectations) > 0 {
		mmFetchScore.mock.t.Fatalf("Some expectations are already set for the Game.FetchScore method")
	}

	mmFetchScore.mock.funcFetchScore = f
	return mmFetchScore.mock
}

// When sets expectation for the Game.FetchScore which will trigger the result defined by the following
// Then helper
func (mmFetchScore *mGameMockFetchScore) When(ctx context.Context, chatID int64) *GameMockFetchScoreExpectation {
	if mmFetchScore.mock.funcFetchScore != nil {
		mmFetchScore.mock.t.Fatalf("GameMock.FetchScore mock is already set by Set")
	}

	expectation := &GameMockFetchScoreExpectation{
		mock:   mmFetchScore.mock,
		params: &GameMockFetchScoreParams{ctx, chatID},
	}
	mmFetchScore.expectations = append(mmFetchScore.expectations, expectation)
	return expectation
}

// Then sets up Game.FetchScore return parameters for the expectation previously defined by the When method
func (e *GameMockFetchScoreExpectation) Then(ua1 []models.User, err error) *GameMock {
	e.results = &GameMockFetchScoreResults{ua1, err}
	return e.mock
}

// FetchScore implements Game
func (mmFetchScore *GameMock) FetchScore(ctx context.Context, chatID int64) (ua1 []models.User, err error) {
	mm_atomic.AddUint64(&mmFetchScore.beforeFetchScoreCounter, 1)
	defer mm_atomic.AddUint64(&mmFetchScore.afterFetchScoreCounter, 1)

	if mmFetchScore.inspectFuncFetchScore != nil {
		mmFetchScore.inspectFuncFetchScore(ctx, chatID)
	}

	mm_params := &GameMockFetchScoreParams{ctx, chatID}

	// Record call args
	mmFetchScore.FetchScoreMock.mutex.Lock()
	mmFetchScore.FetchScoreMock.callArgs = append(mmFetchScore.FetchScoreMock.callArgs, mm_params)
	mmFetchScore.FetchScoreMock.mutex.Unlock()

	for _, e := range mmFetchScore.FetchScoreMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ua1, e.results.err
		}
	}

	if mmFetchScore.FetchScoreMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFetchScore.FetchScoreMock.defaultExpectation.Counter, 1)
		mm_want := mmFetchScore.FetchScoreMock.defaultExpectation.params
		mm_got := GameMockFetchScoreParams{ctx, chatID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmFetchScore.t.Errorf("GameMock.FetchScore got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmFetchScore.FetchScoreMock.defaultExpectation.results
		if mm_results == nil {
			mmFetchScore.t.Fatal("No results are set for the GameMock.FetchScore")
		}
		return (*mm_results).ua1, (*mm_results).err
	}
	if mmFetchScore.funcFetchScore != nil {
		return mmFetchScore.funcFetchScore(ctx, chatID)
	}
	mmFetchScore.t.Fatalf("Unexpected call to GameMock.FetchScore. %v %v", ctx, chatID)
	return
}

// FetchScoreAfterCounter returns a count of finished GameMock.FetchScore invocations
func (mmFetchScore *GameMock) FetchScoreAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFetchScore.afterFetchScoreCounter)
}

// FetchScoreBeforeCounter returns a count of GameMock.FetchScore invocations
func (mmFetchScore *GameMock) FetchScoreBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFetchScore.beforeFetchScoreCounter)
}

// Calls returns a list of arguments used in each call to GameMock.FetchScore.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmFetchScore *mGameMockFetchScore) Calls() []*GameMockFetchScoreParams {
	mmFetchScore.mutex.RLock()

	argCopy := make([]*GameMockFetchScoreParams, len(mmFetchScore.callArgs))
	copy(argCopy, mmFetchScore.callArgs)

	mmFetchScore.mutex.RUnlock()

	return argCopy
}

// MinimockFetchScoreDone returns true if the count of the FetchScore invocations corresponds
// the number of defined expectations
func (m *GameMock) MinimockFetchScoreDone() bool {
	for _, e := range m.FetchScoreMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FetchScoreMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFetchScoreCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFetchScore != nil && mm_atomic.LoadUint64(&m.afterFetchScoreCounter) < 1 {
		return false
	}
	return true
}

// MinimockFetchScoreInspect logs each unmet expectation
func (m *GameMock) MinimockFetchScoreInspect() {
	for _, e := range m.FetchScoreMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to GameMock.FetchScore with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FetchScoreMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFetchScoreCounter) < 1 {
		if m.FetchScoreMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to GameMock.FetchScore")
		} else {
			m.t.Errorf("Expected call to GameMock.FetchScore with params: %#v", *m.FetchScoreMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFetchScore != nil && mm_atomic.LoadUint64(&m.afterFetchScoreCounter) < 1 {
		m.t.Error("Expected call to GameMock.FetchScore")
	}
}

type mGameMockFetchSessions struct {
	mock               *GameMock
	defaultExpectation *GameMockFetchSessionsExpectation
	expectations       []*GameMockFetchSessionsExpectation

	callArgs []*GameMockFetchSessionsParams
	mutex    sync.RWMutex
}

// GameMockFetchSessionsExpectation specifies expectation struct of the Game.FetchSessions
type GameMockFetchSessionsExpectation struct {
	mock    *GameMock
	params  *GameMockFetchSessionsParams
	results *GameMockFetchSessionsResults
	Counter uint64
}

// GameMockFetchSessionsParams contains parameters of the Game.FetchSessions
type GameMockFetchSessionsParams struct {
	ctx    context.Context
	chatID int64
}

// GameMockFetchSessionsResults contains results of the Game.FetchSessions
type GameMockFetchSessionsResults struct {
	sa1 []models.Session
	err error
}

// Expect sets up expected params for Game.FetchSessions
func (mmFetchSessions *mGameMockFetchSessions) Expect(ctx context.Context, chatID int64) *mGameMockFetchSessions {
	if mmFetchSessions.mock.funcFetchSessions != nil {
		mmFetchSessions.mock.t.Fatalf("GameMock.FetchSessions mock is already set by Set")
	}

	if mmFetchSessions.defaultExpectation == nil {
		mmFetchSessions.defaultExpectation = &GameMockFetchSessionsExpectation{}
	}

	mmFetchSessions.defaultExpectation.params = &GameMockFetchSessionsParams{ctx, chatID}
	for _, e := range mmFetchSessions.expectations {
		if minimock.Equal(e.params, mmFetchSessions.defaultExpectation.params) {
			mmFetchSessions.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmFetchSessions.defaultExpectation.params)
		}
	}

	return mmFetchSessions
}

// Inspect accepts an inspector function that has same arguments as the Game.FetchSessions
func (mmFetchSessions *mGameMockFetchSessions) Inspect(f func(ctx context.Context, chatID int64)) *mGameMockFetchSessions {
	if mmFetchSessions.mock.inspectFuncFetchSessions != nil {
		mmFetchSessions.mock.t.Fatalf("Inspect function is already set for GameMock.FetchSessions")
	}

	mmFetchSessions.mock.inspectFuncFetchSessions = f

	return mmFetchSessions
}

// Return sets up results that will be returned by Game.FetchSessions
func (mmFetchSessions *mGameMockFetchSessions) Return(sa1 []models.Session, err error) *GameMock {
	if mmFetchSessions.mock.funcFetchSessions != nil {
		mmFetchSessions.mock.t.Fatalf("GameMock.FetchSessions mock is already set by Set")
	}

	if mmFetchSessions.defaultExpectation == nil {
		mmFetchSessions.defaultExpectation = &GameMockFetchSessionsExpectation{mock: mmFetchSessions.mock}
	}
	mmFetchSessions.defaultExpectation.results = &GameMockFetchSessionsResults{sa1, err}
	return mmFetchSessions.mock
}

//Set uses given function f to mock the Game.FetchSessions method
func (mmFetchSessions *mGameMockFetchSessions) Set(f func(ctx context.Context, chatID int64) (sa1 []models.Session, err error)) *GameMock {
	if mmFetchSessions.defaultExpectation != nil {
		mmFetchSessions.mock.t.Fatalf("Default expectation is already set for the Game.FetchSessions method")
	}

	if len(mmFetchSessions.expectations) > 0 {
		mmFetchSessions.mock.t.Fatalf("Some expectations are already set for the Game.FetchSessions method")
	}

	mmFetchSessions.mock.funcFetchSessions = f
	return mmFetchSessions.mock
}

// When sets expectation for the Game.FetchSessions which will trigger the result defined by the following
// Then helper
func (mmFetchSessions *mGameMockFetchSessions) When(ctx context.Context, chatID int64) *GameMockFetchSessionsExpectation {
	if mmFetchSessions.mock.funcFetchSessions != nil {
		mmFetchSessions.mock.t.Fatalf("GameMock.FetchSessions mock is already set by Set")
	}

	expectation := &GameMockFetchSessionsExpectation{
		mock:   mmFetchSessions.mock,
		params: &GameMockFetchSessionsParams{ctx, chatID},
	}
	mmFetchSessions.expectations = append(mmFetchSessions.expectations, expectation)
	return expectation
}

// Then sets up Game.FetchSessions return parameters for the expectation previously defined by the When method
func (e *GameMockFetchSessionsExpectation) Then(sa1 []models.Session, err error) *GameMock {
	e.results = &GameMockFetchSessionsResults{sa1, err}
	return e.mock
}

// FetchSessions implements Game
func (mmFetchSessions *GameMock) FetchSessions(ctx context.Context, chatID int64) (sa1 []models.Session, err error) {
	mm_atomic.AddUint64(&mmFetchSessions.beforeFetchSessionsCounter, 1)
	defer mm_atomic.AddUint64(&mmFetchSessions.afterFetchSessionsCounter, 1)

	if mmFetchSessions.inspectFuncFetchSessions != nil {
		mmFetchSessions.inspectFuncFetchSessions(ctx, chatID)
	}

	mm_params := &GameMockFetchSessionsParams{ctx, chatID}

	// Record call args
	mmFetchSessions.FetchSessionsMock.mutex.Lock()
	mmFetchSessions.FetchSessionsMock.callArgs = append(mmFetchSessions.FetchSessionsMock.callArgs, mm_params)
	mmFetchSessions.FetchSessionsMock.mutex.Unlock()

	for _, e := range mmFetchSessions.FetchSessionsMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sa1, e.results.err
		}
	}

	if mmFetchSessions.FetchSessionsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFetchSessions.FetchSessionsMock.defaultExpectation.Counter, 1)
		mm_want := mmFetchSessions.FetchSessionsMock.defaultExpectation.params
		mm_got := GameMockFetchSessionsParams{ctx, chatID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmFetchSessions.t.Errorf("GameMock.FetchSessions got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmFetchSessions.FetchSessionsMock.defaultExpectation.results
		if mm_results == nil {
			mmFetchSessions.t.Fatal("No results are set for the GameMock.FetchSessions")
		}
		return (*mm_results).sa1, (*mm_results).err
	}
	if mmFetchSessions.funcFetchSessions != nil {
		return mmFetchSessions.funcFetchSessions(ctx, chatID)
	}
	mmFetchSessions.t.Fatalf("Unexpected call to GameMock.FetchSessions. %v %v", ctx, chatID)
	return
}

// FetchSessionsAfterCounter returns a count of finished GameMock.FetchSessions invocations
func (mmFetchSessions *GameMock) FetchSessionsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFetchSessions.afterFetchSessionsCounter)
}

// FetchSessionsBeforeCounter returns a count of GameMock.FetchSessions invocations
func (mmFetchSessions *GameMock) FetchSessionsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFetchSessions.beforeFetchSessionsCounter)
}

// Calls returns a list of arguments used in each call to GameMock.FetchSessions.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmFetchSessions *mGameMockFetchSessions) Calls() []*GameMockFetchSessionsParams {
	mmFetchSessions.mutex.RLock()

	argCopy := make([]*GameMockFetchSessionsParams, len(mmFetchSessions.callArgs))
	copy(argCopy, mmFetchSessions.callArgs)

	mmFetchSessions.mutex.RUnlock()

	return argCopy
}

// MinimockFetchSessionsDone returns true if the count of the FetchSessions invocations corresponds
// the number of defined expectations
func (m *GameMock) MinimockFetchSessionsDone() bool {
	for _, e := range m.FetchSessionsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FetchSessionsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFetchSessionsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFetchSessions != nil && mm_atomic.LoadUint64(&m.afterFetchSessionsCounter) < 1 {
		return false
	}
	return true
}

// MinimockFetchSessionsInspect logs each unmet expectation
func (m *GameMock) MinimockFetchSessionsInspect() {
	for _, e := range m.FetchSessionsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to GameMock.FetchSessions with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FetchSessionsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFetchSessionsCounter) < 1 {
		if m.FetchSessionsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to GameMock.FetchSessions")
		} else {
			m.t.Errorf("Expected call to GameMock.FetchSessions with params: %#v", *m.FetchSessionsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFetchSessions != nil && mm_atomic.LoadUint64(&m.afterFetchSessionsCounter) < 1 {
		m.t.Error("Expected call to GameMock.FetchSessions")
	}
}

type mGameMockFindTournament struct {
	mock               *GameMock
	defaultExpectation *GameMockFindTournamentExpectation
	expectations       []*GameMockFindTournamentExpectation

	callArgs []*GameMockFindTournamentParams
	mutex    sync.RWMutex
}

// GameMockFindTournamentExpectation specifies expectation struct of the Game.FindTournament
type GameMockFindTournamentExpectation struct {
	mock    *GameMock
	params  *GameMockFindTournamentParams
	results *GameMockFindTournamentResults
	Counter uint64
}

// GameMockFindTournamentParams contains parameters of the Game.FindTournament
type GameMockFindTournamentParams struct {
	ctx  context.Context
	name string
}

// GameMockFindTournamentResults contains results of the Game.FindTournament
type GameMockFindTournamentResults struct {
	t1  models.Tournament
	err error
}

// Expect sets up expected params for Game.FindTournament
func (mmFindTournament *mGameMockFindTournament) Expect(ctx context.Context, name string) *mGameMockFindTournament {
	if mmFindTournament.mock.funcFindTournament != nil {
		mmFindTournament.mock.t.Fatalf("GameMock.FindTournament mock is already set by Set")
	}

	if mmFindTournament.defaultExpectation == nil {
		mmFindTournament.defaultExpectation = &GameMockFindTournamentExpectation{}
	}

	mmFindTournament.defaultExpectation.params = &GameMockFindTournamentParams{ctx, name}
	for _, e := range mmFindTournament.expectations {
		if minimock.Equal(e.params, mmFindTournament.defaultExpectation.params) {
			mmFindTournament.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmFindTournament.defaultExpectation.params)
		}
	}

	return mmFindTournament
}

// Inspect accepts an inspector function that has same arguments as the Game.FindTournament
func (mmFindTournament *mGameMockFindTournament) Inspect(f func(ctx context.Context, name string)) *mGameMockFindTournament {
	if mmFindTournament.mock.inspectFuncFindTournament != nil {
		mmFindTournament.mock.t.Fatalf("Inspect function is already set for GameMock.FindTournament")
	}

	mmFindTournament.mock.inspectFuncFindTournament = f

	return mmFindTournament
}

// Return sets up results that will be returned by Game.FindTournament
func (mmFindTournament *mGameMockFindTournament) Return(t1 models.Tournament, err error) *GameMock {
	if mmFindTournament.mock.funcFindTournament != nil {
		mmFindTournament.mock.t.Fatalf("GameMock.FindTournament mock is already set by Set")
	}

	if mmFindTournament.defaultExpectation == nil {
		mmFindTournament.defaultExpectation = &GameMockFindTournamentExpectation{mock: mmFindTournament.mock}
	}
	mmFindTournament.defaultExpectation.results = &GameMockFindTournamentResults{t1, err}
	return mmFindTournament.mock
}

//Set uses given function f to mock the Game.FindTournament method
func (mmFindTournament *mGameMockFindTournament) Set(f func(ctx context.Context, name string) (t1 models.Tournament, err error)) *GameMock {
	if mmFindTournament.defaultExpectation != nil {
		mmFindTournament.mock.t.Fatalf("Default expectation is already set for the Game.FindTournament method")
	}

	if len(mmFindTournament.expectations) > 0 {
		mmFindTournament.mock.t.Fatalf("Some expectations are already set for the Game.FindTournament method")
	}

	mmFindTournament.mock.funcFindTournament = f
	return mmFindTournament.mock
}

// When sets expectation for the Game.FindTournament which will trigger the result defined by the following
// Then helper
func (mmFindTournament *mGameMockFindTournament) When(ctx context.Context, name string) *GameMockFindTournamentExpectation {
	if mmFindTournament.mock.funcFindTournament != nil {
		mmFindTournament.mock.t.Fatalf("GameMock.FindTournament mock is already set by Set")
	}

	expectation := &GameMockFindTournamentExpectation{
		mock:   mmFindTournament.mock,
		params: &GameMockFindTournamentParams{ctx, name},
	}
	mmFindTournament.expectations = append(mmFindTournament.expectations, expectation)
	return expectation
}

// Then sets up Game.FindTournament return parameters for the expectation previously defined by the When method
func (e *GameMockFindTournamentExpectation) Then(t1 models.Tournament, err error) *GameMock {
	e.results = &GameMockFindTournamentResults{t1, err}
	return e.mock
}

// FindTournament implements Game
func (mmFindTournament *GameMock) FindTournament(ctx context.Context, name string) (t1 models.Tournament, err error) {
	mm_atomic.AddUint64(&mmFindTournament.beforeFindTournamentCounter, 1)
	defer mm_atomic.AddUint64(&mmFindTournament.afterFindTournamentCounter, 1)

	if mmFindTournament.inspectFuncFindTournament != nil {
		mmFindTournament.inspectFuncFindTournament(ctx, name)
	}

	mm_params := &GameMockFindTournamentParams{ctx, name}

	// Record call args
	mmFindTournament.FindTournamentMock.mutex.Lock()
	mmFindTournament.FindTournamentMock.callArgs = append(mmFindTournament.FindTournamentMock.callArgs, mm_params)
	mmFindTournament.FindTournamentMock.mutex.Unlock()

	for _, e := range mmFindTournament.FindTournamentMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.t1, e.results.err
		}
	}

	if mmFindTournament.FindTournamentMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFindTournament.FindTournamentMock.defaultExpectation.Counter, 1)
		mm_want := mmFindTournament.FindTournamentMock.defaultExpectation.params
		mm_got := GameMockFindTournamentParams{ctx, name}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmFindTournament.t.Errorf("GameMock.FindTournament got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmFindTournament.FindTournamentMock.defaultExpectation.results
		if mm_results == nil {
			mmFindTournament.t.Fatal("No results are set for the GameMock.FindTournament")
		}
		return (*mm_results).t1, (*mm_results).err
	}
	if mmFindTournament.funcFindTournament != nil {
		return mmFindTournament.funcFindTournament(ctx, name)
	}
	mmFindTournament.t.Fatalf("Unexpected call to GameMock.FindTournament. %v %v", ctx, name)
	return
}

// FindTournamentAfterCounter returns a count of finished GameMock.FindTournament invocations
func (mmFindTournament *GameMock) FindTournamentAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFindTournament.afterFindTournamentCounter)
}

// FindTournamentBeforeCounter returns a count of GameMock.FindTournament invocations
func (mmFindTournament *GameMock) FindTournamentBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFindTournament.beforeFindTournamentCounter)
}

// Calls returns a list of arguments used in each call to GameMock.FindTournament.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmFindTournament *mGameMockFindTournament) Calls() []*GameMockFindTournamentParams {
	mmFindTournament.mutex.RLock()

	argCopy := make([]*GameMockFindTournamentParams, len(mmFindTournament.callArgs))
	copy(argCopy, mmFindTournament.callArgs)

	mmFindTournament.mutex.RUnlock()

	return argCopy
}

// MinimockFindTournamentDone returns true if the count of the FindTournament invocations corresponds
// the number of defined expectations
func (m *GameMock) MinimockFindTournamentDone() bool {
	for _, e := range m.FindTournamentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FindTournamentMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFindTournamentCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFindTournament != nil && mm_atomic.LoadUint64(&m.afterFindTournamentCounter) < 1 {
		return false
	}
	return true
}

// MinimockFindTournamentInspect logs each unmet expectation
func (m *GameMock) MinimockFindTournamentInspect() {
	for _, e := range m.FindTournamentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to GameMock.FindTournament with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FindTournamentMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFindTournamentCounter) < 1 {
		if m.FindTournamentMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to GameMock.FindTournament")
		} else {
			m.t.Errorf("Expected call to GameMock.FindTournament with params: %#v", *m.FindTournamentMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFindTournament != nil && mm_atomic.LoadUint64(&m.afterFindTournamentCounter) < 1 {
		m.t.Error("Expected call to GameMock.FindTournament")
	}
}

type mGameMockFinishSession struct {
	mock               *GameMock
	defaultExpectation *GameMockFinishSessionExpectation
	expectations       []*GameMockFinishSessionExpectation

	callArgs []*GameMockFinishSessionParams
	mutex    sync.RWMutex
}

// GameMockFinishSessionExpectation specifies expectation struct of the Game.FinishSession
type GameMockFinishSessionExpectation struct {
	mock    *GameMock
	params  *GameMockFinishSessionParams
	results *GameMockFinishSessionResults
	Counter uint64
}

// GameMockFinishSessionParams contains parameters of the Game.FinishSession
type GameMockFinishSessionParams struct {
	ctx    context.Context
	chatID int64
}

// GameMockFinishSessionResults contains results of the Game.FinishSession
type GameMockFinishSessionResults struct {
	err error
}

// Expect sets up expected params for Game.FinishSession
func (mmFinishSession *mGameMockFinishSession) Expect(ctx context.Context, chatID int64) *mGameMockFinishSession {
	if mmFinishSession.mock.funcFinishSession != nil {
		mmFinishSession.mock.t.Fatalf("GameMock.FinishSession mock is already set by Set")
	}

	if mmFinishSession.defaultExpectation == nil {
		mmFinishSession.defaultExpectation = &GameMockFinishSessionExpectation{}
	}

	mmFinishSession.defaultExpectation.params = &GameMockFinishSessionParams{ctx, chatID}
	for _, e := range mmFinishSession.expectations {
		if minimock.Equal(e.params, mmFinishSession.defaultExpectation.params) {
			mmFinishSession.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmFinishSession.defaultExpectation.params)
		}
	}

	return mmFinishSession
}

// Inspect accepts an inspector function that has same arguments as the Game.FinishSession
func (mmFinishSession *mGameMockFinishSession) Inspect(f func(ctx context.Context, chatID int64)) *mGameMockFinishSession {
	if mmFinishSession.mock.inspectFuncFinishSession != nil {
		mmFinishSession.mock.t.Fatalf("Inspect function is already set for GameMock.FinishSession")
	}

	mmFinishSession.mock.inspectFuncFinishSession = f

	return mmFinishSession
}

// Return sets up results that will be returned by Game.FinishSession
func (mmFinishSession *mGameMockFinishSession) Return(err error) *GameMock {
	if mmFinishSession.mock.funcFinishSession != nil {
		mmFinishSession.mock.t.Fatalf("GameMock.FinishSession mock is already set by Set")
	}

	if mmFinishSession.defaultExpectation == nil {
		mmFinishSession.defaultExpectation = &GameMockFinishSessionExpectation{mock: mmFinishSession.mock}
	}
	mmFinishSession.defaultExpectation.results = &GameMockFinishSessionResults{err}
	return mmFinishSession.mock
}

//Set uses given function f to mock the Game.FinishSession method
func (mmFinishSession *mGameMockFinishSession) Set(f func(ctx context.Context, chatID int64) (err error)) *GameMock {
	if mmFinishSession.defaultExpectation != nil {
		mmFinishSession.mock.t.Fatalf("Default expectation is already set for the Game.FinishSession method")
	}

	if len(mmFinishSession.expectations) > 0 {
		mmFinishSession.mock.t.Fatalf("Some expectations are already set for the Game.FinishSession method")
	}

	mmFinishSession.mock.funcFinishSession = f
	return mmFinishSession.mock
}

// When sets expectation for the Game.FinishSession which will trigger the result defined by the following
// Then helper
func (mmFinishSession *mGameMockFinishSession) When(ctx context.Context, chatID int64) *GameMockFinishSessionExpectation {
	if mmFinishSession.mock.funcFinishSession != nil {
		mmFinishSession.mock.t.Fatalf("GameMock.FinishSession mock is already set by Set")
	}

	expectation := &GameMockFinishSessionExpectation{
		mock:   mmFinishSession.mock,
		params: &GameMockFinishSessionParams{ctx, chatID},
	}
	mmFinishSession.expectations = append(mmFinishSession.expectations, expectation)
	return expectation
}

// Then sets up Game.FinishSession return parameters for the expectation previously defined by the When method
func (e *GameMockFinishSessionExpectation) Then(err error) *GameMock {
	e.results = &GameMockFinishSessionResults{err}
	return e.mock
}

// FinishSession implements Game
func (mmFinishSession *GameMock) FinishSession(ctx context.Context, chatID int64) (err error) {
	mm_atomic.AddUint64(&mmFinishSession.beforeFinishSessionCounter, 1)
	defer mm_atomic.AddUint64(&mmFinishSession.afterFinishSessionCounter, 1)

	if mmFinishSession.inspectFuncFinishSession != nil {
		mmFinishSession.inspectFuncFinishSession(ctx, chatID)
	}

	mm_params := &GameMockFinishSessionParams{ctx, chatID}

	// Record call args
	mmFinishSession.FinishSessionMock.mutex.Lock()
	mmFinishSession.FinishSessionMock.callArgs = append(mmFinishSession.FinishSessionMock.callArgs, mm_params)
	mmFinishSession.FinishSessionMock.mutex.Unlock()

	for _, e := range mmFinishSession.FinishSessionMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmFinishSession.FinishSessionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFinishSession.FinishSessionMock.defaultExpectation.Counter, 1)
		mm_want := mmFinishSession.FinishSessionMock.defaultExpectation.params
		mm_got := GameMockFinishSessionParams{ctx, chatID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmFinishSession.t.Errorf("GameMock.FinishSession got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmFinishSession.FinishSessionMock.defaultExpectation.results
		if mm_results == nil {
			mmFinishSession.t.Fatal("No results are set for the GameMock.FinishSession")
		}
		return (*mm_results).err
	}
	if mmFinishSession.funcFinishSession != nil {
		return mmFinishSession.funcFinishSession(ctx, chatID)
	}
	mmFinishSession.t.Fatalf("Unexpected call to GameMock.FinishSession. %v %v", ctx, chatID)
	return
}

// FinishSessionAfterCounter returns a count of finished GameMock.FinishSession invocations
func (mmFinishSession *GameMock) FinishSessionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFinishSession.afterFinishSessionCounter)
}

// FinishSessionBeforeCounter returns a count of GameMock.FinishSession invocations
func (mmFinishSession *GameMock) FinishSessionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFinishSession.beforeFinishSessionCounter)
}

// Calls returns a list of arguments used in each call to GameMock.FinishSession.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmFinishSession *mGameMockFinishSession) Calls() []*GameMockFinishSessionParams {
	mmFinishSession.mutex.RLock()

	argCopy := make([]*GameMockFinishSessionParams, len(mmFinishSession.callArgs))
	copy(argCopy, mmFinishSession.callArgs)

	mmFinishSession.mutex.RUnlock()

	return argCopy
}

// MinimockFinishSessionDone returns true if the count of the FinishSession invocations corresponds
// the number of defined expectations
func (m *GameMock) MinimockFinishSessionDone() bool {
	for _, e := range m.FinishSessionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FinishSessionMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFinishSessionCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFinishSession != nil && mm_atomic.LoadUint64(&m.afterFinishSessionCounter) < 1 {
		return false
	}
	return true
}

// MinimockFinishSessionInspect logs each unmet expectation
func (m *GameMock) MinimockFinishSessionInspect() {
	for _, e := range m.FinishSessionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to GameMock.FinishSession with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FinishSessionMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFinishSessionCounter) < 1 {
		if m.FinishSessionMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to GameMock.FinishSession")
		} else {
			m.t.Errorf("Expected call to GameMock.FinishSession with params: %#v", *m.FinishSessionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFinishSession != nil && mm_atomic.LoadUint64(&m.afterFinishSessionCounter) < 1 {
		m.t.Error("Expected call to GameMock.FinishSession")
	}
}

type mGameMockRandomTournaments struct {
	mock               *GameMock
	defaultExpectation *GameMockRandomTournamentsExpectation
	expectations       []*GameMockRandomTournamentsExpectation

	callArgs []*GameMockRandomTournamentsParams
	mutex    sync.RWMutex
}

// GameMockRandomTournamentsExpectation specifies expectation struct of the Game.RandomTournaments
type GameMockRandomTournamentsExpectation struct {
	mock    *GameMock
	params  *GameMockRandomTournamentsParams
	results *GameMockRandomTournamentsResults
	Counter uint64
}

// GameMockRandomTournamentsParams contains parameters of the Game.RandomTournaments
type GameMockRandomTournamentsParams struct {
	ctx context.Context
}

// GameMockRandomTournamentsResults contains results of the Game.RandomTournaments
type GameMockRandomTournamentsResults struct {
	ta1 []models.TourI
	err error
}

// Expect sets up expected params for Game.RandomTournaments
func (mmRandomTournaments *mGameMockRandomTournaments) Expect(ctx context.Context) *mGameMockRandomTournaments {
	if mmRandomTournaments.mock.funcRandomTournaments != nil {
		mmRandomTournaments.mock.t.Fatalf("GameMock.RandomTournaments mock is already set by Set")
	}

	if mmRandomTournaments.defaultExpectation == nil {
		mmRandomTournaments.defaultExpectation = &GameMockRandomTournamentsExpectation{}
	}

	mmRandomTournaments.defaultExpectation.params = &GameMockRandomTournamentsParams{ctx}
	for _, e := range mmRandomTournaments.expectations {
		if minimock.Equal(e.params, mmRandomTournaments.defaultExpectation.params) {
			mmRandomTournaments.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRandomTournaments.defaultExpectation.params)
		}
	}

	return mmRandomTournaments
}

// Inspect accepts an inspector function that has same arguments as the Game.RandomTournaments
func (mmRandomTournaments *mGameMockRandomTournaments) Inspect(f func(ctx context.Context)) *mGameMockRandomTournaments {
	if mmRandomTournaments.mock.inspectFuncRandomTournaments != nil {
		mmRandomTournaments.mock.t.Fatalf("Inspect function is already set for GameMock.RandomTournaments")
	}

	mmRandomTournaments.mock.inspectFuncRandomTournaments = f

	return mmRandomTournaments
}

// Return sets up results that will be returned by Game.RandomTournaments
func (mmRandomTournaments *mGameMockRandomTournaments) Return(ta1 []models.TourI, err error) *GameMock {
	if mmRandomTournaments.mock.funcRandomTournaments != nil {
		mmRandomTournaments.mock.t.Fatalf("GameMock.RandomTournaments mock is already set by Set")
	}

	if mmRandomTournaments.defaultExpectation == nil {
		mmRandomTournaments.defaultExpectation = &GameMockRandomTournamentsExpectation{mock: mmRandomTournaments.mock}
	}
	mmRandomTournaments.defaultExpectation.results = &GameMockRandomTournamentsResults{ta1, err}
	return mmRandomTournaments.mock
}

//Set uses given function f to mock the Game.RandomTournaments method
func (mmRandomTournaments *mGameMockRandomTournaments) Set(f func(ctx context.Context) (ta1 []models.TourI, err error)) *GameMock {
	if mmRandomTournaments.defaultExpectation != nil {
		mmRandomTournaments.mock.t.Fatalf("Default expectation is already set for the Game.RandomTournaments method")
	}

	if len(mmRandomTournaments.expectations) > 0 {
		mmRandomTournaments.mock.t.Fatalf("Some expectations are already set for the Game.RandomTournaments method")
	}

	mmRandomTournaments.mock.funcRandomTournaments = f
	return mmRandomTournaments.mock
}

// When sets expectation for the Game.RandomTournaments which will trigger the result defined by the following
// Then helper
func (mmRandomTournaments *mGameMockRandomTournaments) When(ctx context.Context) *GameMockRandomTournamentsExpectation {
	if mmRandomTournaments.mock.funcRandomTournaments != nil {
		mmRandomTournaments.mock.t.Fatalf("GameMock.RandomTournaments mock is already set by Set")
	}

	expectation := &GameMockRandomTournamentsExpectation{
		mock:   mmRandomTournaments.mock,
		params: &GameMockRandomTournamentsParams{ctx},
	}
	mmRandomTournaments.expectations = append(mmRandomTournaments.expectations, expectation)
	return expectation
}

// Then sets up Game.RandomTournaments return parameters for the expectation previously defined by the When method
func (e *GameMockRandomTournamentsExpectation) Then(ta1 []models.TourI, err error) *GameMock {
	e.results = &GameMockRandomTournamentsResults{ta1, err}
	return e.mock
}

// RandomTournaments implements Game
func (mmRandomTournaments *GameMock) RandomTournaments(ctx context.Context) (ta1 []models.TourI, err error) {
	mm_atomic.AddUint64(&mmRandomTournaments.beforeRandomTournamentsCounter, 1)
	defer mm_atomic.AddUint64(&mmRandomTournaments.afterRandomTournamentsCounter, 1)

	if mmRandomTournaments.inspectFuncRandomTournaments != nil {
		mmRandomTournaments.inspectFuncRandomTournaments(ctx)
	}

	mm_params := &GameMockRandomTournamentsParams{ctx}

	// Record call args
	mmRandomTournaments.RandomTournamentsMock.mutex.Lock()
	mmRandomTournaments.RandomTournamentsMock.callArgs = append(mmRandomTournaments.RandomTournamentsMock.callArgs, mm_params)
	mmRandomTournaments.RandomTournamentsMock.mutex.Unlock()

	for _, e := range mmRandomTournaments.RandomTournamentsMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ta1, e.results.err
		}
	}

	if mmRandomTournaments.RandomTournamentsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRandomTournaments.RandomTournamentsMock.defaultExpectation.Counter, 1)
		mm_want := mmRandomTournaments.RandomTournamentsMock.defaultExpectation.params
		mm_got := GameMockRandomTournamentsParams{ctx}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRandomTournaments.t.Errorf("GameMock.RandomTournaments got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRandomTournaments.RandomTournamentsMock.defaultExpectation.results
		if mm_results == nil {
			mmRandomTournaments.t.Fatal("No results are set for the GameMock.RandomTournaments")
		}
		return (*mm_results).ta1, (*mm_results).err
	}
	if mmRandomTournaments.funcRandomTournaments != nil {
		return mmRandomTournaments.funcRandomTournaments(ctx)
	}
	mmRandomTournaments.t.Fatalf("Unexpected call to GameMock.RandomTournaments. %v", ctx)
	return
}

// RandomTournamentsAfterCounter returns a count of finished GameMock.RandomTournaments invocations
func (mmRandomTournaments *GameMock) RandomTournamentsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRandomTournaments.afterRandomTournamentsCounter)
}

// RandomTournamentsBeforeCounter returns a count of GameMock.RandomTournaments invocations
func (mmRandomTournaments *GameMock) RandomTournamentsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRandomTournaments.beforeRandomTournamentsCounter)
}

// Calls returns a list of arguments used in each call to GameMock.RandomTournaments.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRandomTournaments *mGameMockRandomTournaments) Calls() []*GameMockRandomTournamentsParams {
	mmRandomTournaments.mutex.RLock()

	argCopy := make([]*GameMockRandomTournamentsParams, len(mmRandomTournaments.callArgs))
	copy(argCopy, mmRandomTournaments.callArgs)

	mmRandomTournaments.mutex.RUnlock()

	return argCopy
}

// MinimockRandomTournamentsDone returns true if the count of the RandomTournaments invocations corresponds
// the number of defined expectations
func (m *GameMock) MinimockRandomTournamentsDone() bool {
	for _, e := range m.RandomTournamentsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RandomTournamentsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRandomTournamentsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRandomTournaments != nil && mm_atomic.LoadUint64(&m.afterRandomTournamentsCounter) < 1 {
		return false
	}
	return true
}

// MinimockRandomTournamentsInspect logs each unmet expectation
func (m *GameMock) MinimockRandomTournamentsInspect() {
	for _, e := range m.RandomTournamentsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to GameMock.RandomTournaments with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RandomTournamentsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRandomTournamentsCounter) < 1 {
		if m.RandomTournamentsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to GameMock.RandomTournaments")
		} else {
			m.t.Errorf("Expected call to GameMock.RandomTournaments with params: %#v", *m.RandomTournamentsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRandomTournaments != nil && mm_atomic.LoadUint64(&m.afterRandomTournamentsCounter) < 1 {
		m.t.Error("Expected call to GameMock.RandomTournaments")
	}
}

type mGameMockSubmitGuess struct {
	mock               *GameMock
	defaultExpectation *GameMockSubmitGuessExpectation
	expectations       []*GameMockSubmitGuessExpectation

	callArgs []*GameMockSubmitGuessParams
	mutex    sync.RWMutex
}

// GameMockSubmitGuessExpectation specifies expectation struct of the Game.SubmitGuess
type GameMockSubmitGuessExpectation struct {
	mock    *GameMock
	params  *GameMockSubmitGuessParams
	results *GameMockSubmitGuessResults
	Counter uint64
}

// GameMockSubmitGuessParams contains parameters of the Game.SubmitGuess
type GameMockSubmitGuessParams struct {
	ctx        context.Context
	chatID     int64
	questionID int64
	username   string
	guess      string
}

// GameMockSubmitGuessResults contains results of the Game.SubmitGuess
type GameMockSubmitGuessResults struct {
	b1  bool
	err error
}

// Expect sets up expected params for Game.SubmitGuess
func (mmSubmitGuess *mGameMockSubmitGuess) Expect(ctx context.Context, chatID int64, questionID int64, username string, guess string) *mGameMockSubmitGuess {
	if mmSubmitGuess.mock.funcSubmitGuess != nil {
		mmSubmitGuess.mock.t.Fatalf("GameMock.SubmitGuess mock is already set by Set")
	}

	if mmSubmitGuess.defaultExpectation == nil {
		mmSubmitGuess.defaultExpectation = &GameMockSubmitGuessExpectation{}
	}

	mmSubmitGuess.defaultExpectation.params = &GameMockSubmitGuessParams{ctx, chatID, questionID, username, guess}
	for _, e := range mmSubmitGuess.expectations {
		if minimock.Equal(e.params, mmSubmitGuess.defaultExpectation.params) {
			mmSubmitGuess.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSubmitGuess.defaultExpectation.params)
		}
	}

	return mmSubmitGuess
}

// Inspect accepts an inspector function that has same arguments as the Game.SubmitGuess
func (mmSubmitGuess *mGameMockSubmitGuess) Inspect(f func(ctx context.Context, chatID int64, questionID int64, username string, guess string)) *mGameMockSubmitGuess {
	if mmSubmitGuess.mock.inspectFuncSubmitGuess != nil {
		mmSubmitGuess.mock.t.Fatalf("Inspect function is already set for GameMock.SubmitGuess")
	}

	mmSubmitGuess.mock.inspectFuncSubmitGuess = f

	return mmSubmitGuess
}

// Return sets up results that will be returned by Game.SubmitGuess
func (mmSubmitGuess *mGameMockSubmitGuess) Return(b1 bool, err error) *GameMock {
	if mmSubmitGuess.mock.funcSubmitGuess != nil {
		mmSubmitGuess.mock.t.Fatalf("GameMock.SubmitGuess mock is already set by Set")
	}

	if mmSubmitGuess.defaultExpectation == nil {
		mmSubmitGuess.defaultExpectation = &GameMockSubmitGuessExpectation{mock: mmSubmitGuess.mock}
	}
	mmSubmitGuess.defaultExpectation.results = &GameMockSubmitGuessResults{b1, err}
	return mmSubmitGuess.mock
}

//Set uses given function f to mock the Game.SubmitGuess method
func (mmSubmitGuess *mGameMockSubmitGuess) Set(f func(ctx context.Context, chatID int64, questionID int64, username string, guess string) (b1 bool, err error)) *GameMock {
	if mmSubmitGuess.defaultExpectation != nil {
		mmSubmitGuess.mock.t.Fatalf("Default expectation is already set for the Game.SubmitGuess method")
	}

	if len(mmSubmitGuess.expectations) > 0 {
		mmSubmitGuess.mock.t.Fatalf("Some expectations are already set for the Game.SubmitGuess method")
	}

	mmSubmitGuess.mock.funcSubmitGuess = f
	return mmSubmitGuess.mock
}

// When sets expectation for the Game.SubmitGuess which will trigger the result defined by the following
// Then helper
func (mmSubmitGuess *mGameMockSubmitGuess) When(ctx context.Context, chatID int64, questionID int64, username string, guess string) *GameMockSubmitGuessExpectation {
	if mmSubmitGuess.mock.funcSubmitGuess != nil {
		mmSubmitGuess.mock.t.Fatalf("GameMock.SubmitGuess mock is already set by Set")
	}

	expectation := &GameMockSubmitGuessExpectation{
		mock:   mmSubmitGuess.mock,
		params: &GameMockSubmitGuessParams{ctx, chatID, questionID, username, guess},
	}
	mmSubmitGuess.expectations = append(mmSubmitGuess.expectations, expectation)
	return expectation
}

// Then sets up Game.SubmitGuess return parameters for the expectation previously defined by the When method
func (e *GameMockSubmitGuessExpectation) Then(b1 bool, err error) *GameMock {
	e.results = &GameMockSubmitGuessResults{b1, err}
	return e.mock
}

// SubmitGuess implements Game
func (mmSubmitGuess *GameMock) SubmitGuess(ctx context.Context, chatID int64, questionID int64, username string, guess string) (b1 bool, err error) {
	mm_atomic.AddUint64(&mmSubmitGuess.beforeSubmitGuessCounter, 1)
	defer mm_atomic.AddUint64(&mmSubmitGuess.afterSubmitGuessCounter, 1)

	if mmSubmitGuess.inspectFuncSubmitGuess != nil {
		mmSubmitGuess.inspectFuncSubmitGuess(ctx, chatID, questionID, username, guess)
	}

	mm_params := &GameMockSubmitGuessParams{ctx, chatID, questionID, username, guess}

	// Record call args
	mmSubmitGuess.SubmitGuessMock.mutex.Lock()
	mmSubmitGuess.SubmitGuessMock.callArgs = append(mmSubmitGuess.SubmitGuessMock.callArgs, mm_params)
	mmSubmitGuess.SubmitGuessMock.mutex.Unlock()

	for _, e := range mmSubmitGuess.SubmitGuessMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1, e.results.err
		}
	}

	if mmSubmitGuess.SubmitGuessMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSubmitGuess.SubmitGuessMock.defaultExpectation.Counter, 1)
		mm_want := mmSubmitGuess.SubmitGuessMock.defaultExpectation.params
		mm_got := GameMockSubmitGuessParams{ctx, chatID, questionID, username, guess}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSubmitGuess.t.Errorf("GameMock.SubmitGuess got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSubmitGuess.SubmitGuessMock.defaultExpectation.results
		if mm_results == nil {
			mmSubmitGuess.t.Fatal("No results are set for the GameMock.SubmitGuess")
		}
		return (*mm_results).b1, (*mm_results).err
	}
	if mmSubmitGuess.funcSubmitGuess != nil {
		return mmSubmitGuess.funcSubmitGuess(ctx, chatID, questionID, username, guess)
	}
	mmSubmitGuess.t.Fatalf("Unexpected call to GameMock.SubmitGuess. %v %v %v %v %v", ctx, chatID, questionID, username, guess)
	return
}

// SubmitGuessAfterCounter returns a count of finished GameMock.SubmitGuess invocations
func (mmSubmitGuess *GameMock) SubmitGuessAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSubmitGuess.afterSubmitGuessCounter)
}

// SubmitGuessBeforeCounter returns a count of GameMock.SubmitGuess invocations
func (mmSubmitGuess *GameMock) SubmitGuessBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSubmitGuess.beforeSubmitGuessCounter)
}

// Calls returns a list of arguments used in each call to GameMock.SubmitGuess.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSubmitGuess *mGameMockSubmitGuess) Calls() []*GameMockSubmitGuessParams {
	mmSubmitGuess.mutex.RLock()

	argCopy := make([]*GameMockSubmitGuessParams, len(mmSubmitGuess.callArgs))
	copy(argCopy, mmSubmitGuess.callArgs)

	mmSubmitGuess.mutex.RUnlock()

	return argCopy
}

// MinimockSubmitGuessDone returns true if the count of the SubmitGuess invocations corresponds
// the number of defined expectations
func (m *GameMock) MinimockSubmitGuessDone() bool {
	for _, e := range m.SubmitGuessMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SubmitGuessMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSubmitGuessCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSubmitGuess != nil && mm_atomic.LoadUint64(&m.afterSubmitGuessCounter) < 1 {
		return false
	}
	return true
}

// MinimockSubmitGuessInspect logs each unmet expectation
func (m *GameMock) MinimockSubmitGuessInspect() {
	for _, e := range m.SubmitGuessMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to GameMock.SubmitGuess with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SubmitGuessMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSubmitGuessCounter) < 1 {
		if m.SubmitGuessMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to GameMock.SubmitGuess")
		} else {
			m.t.Errorf("Expected call to GameMock.SubmitGuess with params: %#v", *m.SubmitGuessMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSubmitGuess != nil && mm_atomic.LoadUint64(&m.afterSubmitGuessCounter) < 1 {
		m.t.Error("Expected call to GameMock.SubmitGuess")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *GameMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockBeginInspect()

		m.MinimockFetchQuestionInspect()

		m.MinimockFetchScoreInspect()

		m.MinimockFetchSessionsInspect()

		m.MinimockFindTournamentInspect()

		m.MinimockFinishSessionInspect()

		m.MinimockRandomTournamentsInspect()

		m.MinimockSubmitGuessInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *GameMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *GameMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockBeginDone() &&
		m.MinimockFetchQuestionDone() &&
		m.MinimockFetchScoreDone() &&
		m.MinimockFetchSessionsDone() &&
		m.MinimockFindTournamentDone() &&
		m.MinimockFinishSessionDone() &&
		m.MinimockRandomTournamentsDone() &&
		m.MinimockSubmitGuessDone()
}
