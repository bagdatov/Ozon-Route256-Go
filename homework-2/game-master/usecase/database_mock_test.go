package usecase

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i gitlab.ozon.dev/bagdatov/homework-2/game-master/usecase.Database -o ./database_mock_test.go -n DatabaseMock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"gitlab.ozon.dev/bagdatov/homework-2/game-master/models"
)

// DatabaseMock implements Database
type DatabaseMock struct {
	t minimock.Tester

	funcAddScore          func(ctx context.Context, chatID int64, questionID int64, user string, isCorrect bool) (err error)
	inspectFuncAddScore   func(ctx context.Context, chatID int64, questionID int64, user string, isCorrect bool)
	afterAddScoreCounter  uint64
	beforeAddScoreCounter uint64
	AddScoreMock          mDatabaseMockAddScore

	funcAddSession          func(ctx context.Context, tournamentID int64, chatID int64) (err error)
	inspectFuncAddSession   func(ctx context.Context, tournamentID int64, chatID int64)
	afterAddSessionCounter  uint64
	beforeAddSessionCounter uint64
	AddSessionMock          mDatabaseMockAddSession

	funcAddTournament          func(ctx context.Context, tournament models.Tournament, tours []models.Tour) (err error)
	inspectFuncAddTournament   func(ctx context.Context, tournament models.Tournament, tours []models.Tour)
	afterAddTournamentCounter  uint64
	beforeAddTournamentCounter uint64
	AddTournamentMock          mDatabaseMockAddTournament

	funcFetchQuestion          func(ctx context.Context, questionID int64) (q1 models.Question, err error)
	inspectFuncFetchQuestion   func(ctx context.Context, questionID int64)
	afterFetchQuestionCounter  uint64
	beforeFetchQuestionCounter uint64
	FetchQuestionMock          mDatabaseMockFetchQuestion

	funcFetchQuestions          func(ctx context.Context, tournamentID int64) (questions []int64, err error)
	inspectFuncFetchQuestions   func(ctx context.Context, tournamentID int64)
	afterFetchQuestionsCounter  uint64
	beforeFetchQuestionsCounter uint64
	FetchQuestionsMock          mDatabaseMockFetchQuestions

	funcFetchScore          func(ctx context.Context, chatID int64) (ua1 []models.User, err error)
	inspectFuncFetchScore   func(ctx context.Context, chatID int64)
	afterFetchScoreCounter  uint64
	beforeFetchScoreCounter uint64
	FetchScoreMock          mDatabaseMockFetchScore

	funcFetchSessions          func(ctx context.Context, chatID int64) (sa1 []models.Session, err error)
	inspectFuncFetchSessions   func(ctx context.Context, chatID int64)
	afterFetchSessionsCounter  uint64
	beforeFetchSessionsCounter uint64
	FetchSessionsMock          mDatabaseMockFetchSessions

	funcFinishSession          func(ctx context.Context, chatID int64) (err error)
	inspectFuncFinishSession   func(ctx context.Context, chatID int64)
	afterFinishSessionCounter  uint64
	beforeFinishSessionCounter uint64
	FinishSessionMock          mDatabaseMockFinishSession

	funcIsCached          func(ctx context.Context, tournamentName string) (cashed bool, tournamentID int64, err error)
	inspectFuncIsCached   func(ctx context.Context, tournamentName string)
	afterIsCachedCounter  uint64
	beforeIsCachedCounter uint64
	IsCachedMock          mDatabaseMockIsCached
}

// NewDatabaseMock returns a mock for Database
func NewDatabaseMock(t minimock.Tester) *DatabaseMock {
	m := &DatabaseMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddScoreMock = mDatabaseMockAddScore{mock: m}
	m.AddScoreMock.callArgs = []*DatabaseMockAddScoreParams{}

	m.AddSessionMock = mDatabaseMockAddSession{mock: m}
	m.AddSessionMock.callArgs = []*DatabaseMockAddSessionParams{}

	m.AddTournamentMock = mDatabaseMockAddTournament{mock: m}
	m.AddTournamentMock.callArgs = []*DatabaseMockAddTournamentParams{}

	m.FetchQuestionMock = mDatabaseMockFetchQuestion{mock: m}
	m.FetchQuestionMock.callArgs = []*DatabaseMockFetchQuestionParams{}

	m.FetchQuestionsMock = mDatabaseMockFetchQuestions{mock: m}
	m.FetchQuestionsMock.callArgs = []*DatabaseMockFetchQuestionsParams{}

	m.FetchScoreMock = mDatabaseMockFetchScore{mock: m}
	m.FetchScoreMock.callArgs = []*DatabaseMockFetchScoreParams{}

	m.FetchSessionsMock = mDatabaseMockFetchSessions{mock: m}
	m.FetchSessionsMock.callArgs = []*DatabaseMockFetchSessionsParams{}

	m.FinishSessionMock = mDatabaseMockFinishSession{mock: m}
	m.FinishSessionMock.callArgs = []*DatabaseMockFinishSessionParams{}

	m.IsCachedMock = mDatabaseMockIsCached{mock: m}
	m.IsCachedMock.callArgs = []*DatabaseMockIsCachedParams{}

	return m
}

type mDatabaseMockAddScore struct {
	mock               *DatabaseMock
	defaultExpectation *DatabaseMockAddScoreExpectation
	expectations       []*DatabaseMockAddScoreExpectation

	callArgs []*DatabaseMockAddScoreParams
	mutex    sync.RWMutex
}

// DatabaseMockAddScoreExpectation specifies expectation struct of the Database.AddScore
type DatabaseMockAddScoreExpectation struct {
	mock    *DatabaseMock
	params  *DatabaseMockAddScoreParams
	results *DatabaseMockAddScoreResults
	Counter uint64
}

// DatabaseMockAddScoreParams contains parameters of the Database.AddScore
type DatabaseMockAddScoreParams struct {
	ctx        context.Context
	chatID     int64
	questionID int64
	user       string
	isCorrect  bool
}

// DatabaseMockAddScoreResults contains results of the Database.AddScore
type DatabaseMockAddScoreResults struct {
	err error
}

// Expect sets up expected params for Database.AddScore
func (mmAddScore *mDatabaseMockAddScore) Expect(ctx context.Context, chatID int64, questionID int64, user string, isCorrect bool) *mDatabaseMockAddScore {
	if mmAddScore.mock.funcAddScore != nil {
		mmAddScore.mock.t.Fatalf("DatabaseMock.AddScore mock is already set by Set")
	}

	if mmAddScore.defaultExpectation == nil {
		mmAddScore.defaultExpectation = &DatabaseMockAddScoreExpectation{}
	}

	mmAddScore.defaultExpectation.params = &DatabaseMockAddScoreParams{ctx, chatID, questionID, user, isCorrect}
	for _, e := range mmAddScore.expectations {
		if minimock.Equal(e.params, mmAddScore.defaultExpectation.params) {
			mmAddScore.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddScore.defaultExpectation.params)
		}
	}

	return mmAddScore
}

// Inspect accepts an inspector function that has same arguments as the Database.AddScore
func (mmAddScore *mDatabaseMockAddScore) Inspect(f func(ctx context.Context, chatID int64, questionID int64, user string, isCorrect bool)) *mDatabaseMockAddScore {
	if mmAddScore.mock.inspectFuncAddScore != nil {
		mmAddScore.mock.t.Fatalf("Inspect function is already set for DatabaseMock.AddScore")
	}

	mmAddScore.mock.inspectFuncAddScore = f

	return mmAddScore
}

// Return sets up results that will be returned by Database.AddScore
func (mmAddScore *mDatabaseMockAddScore) Return(err error) *DatabaseMock {
	if mmAddScore.mock.funcAddScore != nil {
		mmAddScore.mock.t.Fatalf("DatabaseMock.AddScore mock is already set by Set")
	}

	if mmAddScore.defaultExpectation == nil {
		mmAddScore.defaultExpectation = &DatabaseMockAddScoreExpectation{mock: mmAddScore.mock}
	}
	mmAddScore.defaultExpectation.results = &DatabaseMockAddScoreResults{err}
	return mmAddScore.mock
}

//Set uses given function f to mock the Database.AddScore method
func (mmAddScore *mDatabaseMockAddScore) Set(f func(ctx context.Context, chatID int64, questionID int64, user string, isCorrect bool) (err error)) *DatabaseMock {
	if mmAddScore.defaultExpectation != nil {
		mmAddScore.mock.t.Fatalf("Default expectation is already set for the Database.AddScore method")
	}

	if len(mmAddScore.expectations) > 0 {
		mmAddScore.mock.t.Fatalf("Some expectations are already set for the Database.AddScore method")
	}

	mmAddScore.mock.funcAddScore = f
	return mmAddScore.mock
}

// When sets expectation for the Database.AddScore which will trigger the result defined by the following
// Then helper
func (mmAddScore *mDatabaseMockAddScore) When(ctx context.Context, chatID int64, questionID int64, user string, isCorrect bool) *DatabaseMockAddScoreExpectation {
	if mmAddScore.mock.funcAddScore != nil {
		mmAddScore.mock.t.Fatalf("DatabaseMock.AddScore mock is already set by Set")
	}

	expectation := &DatabaseMockAddScoreExpectation{
		mock:   mmAddScore.mock,
		params: &DatabaseMockAddScoreParams{ctx, chatID, questionID, user, isCorrect},
	}
	mmAddScore.expectations = append(mmAddScore.expectations, expectation)
	return expectation
}

// Then sets up Database.AddScore return parameters for the expectation previously defined by the When method
func (e *DatabaseMockAddScoreExpectation) Then(err error) *DatabaseMock {
	e.results = &DatabaseMockAddScoreResults{err}
	return e.mock
}

// AddScore implements Database
func (mmAddScore *DatabaseMock) AddScore(ctx context.Context, chatID int64, questionID int64, user string, isCorrect bool) (err error) {
	mm_atomic.AddUint64(&mmAddScore.beforeAddScoreCounter, 1)
	defer mm_atomic.AddUint64(&mmAddScore.afterAddScoreCounter, 1)

	if mmAddScore.inspectFuncAddScore != nil {
		mmAddScore.inspectFuncAddScore(ctx, chatID, questionID, user, isCorrect)
	}

	mm_params := &DatabaseMockAddScoreParams{ctx, chatID, questionID, user, isCorrect}

	// Record call args
	mmAddScore.AddScoreMock.mutex.Lock()
	mmAddScore.AddScoreMock.callArgs = append(mmAddScore.AddScoreMock.callArgs, mm_params)
	mmAddScore.AddScoreMock.mutex.Unlock()

	for _, e := range mmAddScore.AddScoreMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddScore.AddScoreMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddScore.AddScoreMock.defaultExpectation.Counter, 1)
		mm_want := mmAddScore.AddScoreMock.defaultExpectation.params
		mm_got := DatabaseMockAddScoreParams{ctx, chatID, questionID, user, isCorrect}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddScore.t.Errorf("DatabaseMock.AddScore got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddScore.AddScoreMock.defaultExpectation.results
		if mm_results == nil {
			mmAddScore.t.Fatal("No results are set for the DatabaseMock.AddScore")
		}
		return (*mm_results).err
	}
	if mmAddScore.funcAddScore != nil {
		return mmAddScore.funcAddScore(ctx, chatID, questionID, user, isCorrect)
	}
	mmAddScore.t.Fatalf("Unexpected call to DatabaseMock.AddScore. %v %v %v %v %v", ctx, chatID, questionID, user, isCorrect)
	return
}

// AddScoreAfterCounter returns a count of finished DatabaseMock.AddScore invocations
func (mmAddScore *DatabaseMock) AddScoreAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddScore.afterAddScoreCounter)
}

// AddScoreBeforeCounter returns a count of DatabaseMock.AddScore invocations
func (mmAddScore *DatabaseMock) AddScoreBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddScore.beforeAddScoreCounter)
}

// Calls returns a list of arguments used in each call to DatabaseMock.AddScore.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddScore *mDatabaseMockAddScore) Calls() []*DatabaseMockAddScoreParams {
	mmAddScore.mutex.RLock()

	argCopy := make([]*DatabaseMockAddScoreParams, len(mmAddScore.callArgs))
	copy(argCopy, mmAddScore.callArgs)

	mmAddScore.mutex.RUnlock()

	return argCopy
}

// MinimockAddScoreDone returns true if the count of the AddScore invocations corresponds
// the number of defined expectations
func (m *DatabaseMock) MinimockAddScoreDone() bool {
	for _, e := range m.AddScoreMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddScoreMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddScoreCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddScore != nil && mm_atomic.LoadUint64(&m.afterAddScoreCounter) < 1 {
		return false
	}
	return true
}

// MinimockAddScoreInspect logs each unmet expectation
func (m *DatabaseMock) MinimockAddScoreInspect() {
	for _, e := range m.AddScoreMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DatabaseMock.AddScore with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddScoreMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddScoreCounter) < 1 {
		if m.AddScoreMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to DatabaseMock.AddScore")
		} else {
			m.t.Errorf("Expected call to DatabaseMock.AddScore with params: %#v", *m.AddScoreMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddScore != nil && mm_atomic.LoadUint64(&m.afterAddScoreCounter) < 1 {
		m.t.Error("Expected call to DatabaseMock.AddScore")
	}
}

type mDatabaseMockAddSession struct {
	mock               *DatabaseMock
	defaultExpectation *DatabaseMockAddSessionExpectation
	expectations       []*DatabaseMockAddSessionExpectation

	callArgs []*DatabaseMockAddSessionParams
	mutex    sync.RWMutex
}

// DatabaseMockAddSessionExpectation specifies expectation struct of the Database.AddSession
type DatabaseMockAddSessionExpectation struct {
	mock    *DatabaseMock
	params  *DatabaseMockAddSessionParams
	results *DatabaseMockAddSessionResults
	Counter uint64
}

// DatabaseMockAddSessionParams contains parameters of the Database.AddSession
type DatabaseMockAddSessionParams struct {
	ctx          context.Context
	tournamentID int64
	chatID       int64
}

// DatabaseMockAddSessionResults contains results of the Database.AddSession
type DatabaseMockAddSessionResults struct {
	err error
}

// Expect sets up expected params for Database.AddSession
func (mmAddSession *mDatabaseMockAddSession) Expect(ctx context.Context, tournamentID int64, chatID int64) *mDatabaseMockAddSession {
	if mmAddSession.mock.funcAddSession != nil {
		mmAddSession.mock.t.Fatalf("DatabaseMock.AddSession mock is already set by Set")
	}

	if mmAddSession.defaultExpectation == nil {
		mmAddSession.defaultExpectation = &DatabaseMockAddSessionExpectation{}
	}

	mmAddSession.defaultExpectation.params = &DatabaseMockAddSessionParams{ctx, tournamentID, chatID}
	for _, e := range mmAddSession.expectations {
		if minimock.Equal(e.params, mmAddSession.defaultExpectation.params) {
			mmAddSession.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddSession.defaultExpectation.params)
		}
	}

	return mmAddSession
}

// Inspect accepts an inspector function that has same arguments as the Database.AddSession
func (mmAddSession *mDatabaseMockAddSession) Inspect(f func(ctx context.Context, tournamentID int64, chatID int64)) *mDatabaseMockAddSession {
	if mmAddSession.mock.inspectFuncAddSession != nil {
		mmAddSession.mock.t.Fatalf("Inspect function is already set for DatabaseMock.AddSession")
	}

	mmAddSession.mock.inspectFuncAddSession = f

	return mmAddSession
}

// Return sets up results that will be returned by Database.AddSession
func (mmAddSession *mDatabaseMockAddSession) Return(err error) *DatabaseMock {
	if mmAddSession.mock.funcAddSession != nil {
		mmAddSession.mock.t.Fatalf("DatabaseMock.AddSession mock is already set by Set")
	}

	if mmAddSession.defaultExpectation == nil {
		mmAddSession.defaultExpectation = &DatabaseMockAddSessionExpectation{mock: mmAddSession.mock}
	}
	mmAddSession.defaultExpectation.results = &DatabaseMockAddSessionResults{err}
	return mmAddSession.mock
}

//Set uses given function f to mock the Database.AddSession method
func (mmAddSession *mDatabaseMockAddSession) Set(f func(ctx context.Context, tournamentID int64, chatID int64) (err error)) *DatabaseMock {
	if mmAddSession.defaultExpectation != nil {
		mmAddSession.mock.t.Fatalf("Default expectation is already set for the Database.AddSession method")
	}

	if len(mmAddSession.expectations) > 0 {
		mmAddSession.mock.t.Fatalf("Some expectations are already set for the Database.AddSession method")
	}

	mmAddSession.mock.funcAddSession = f
	return mmAddSession.mock
}

// When sets expectation for the Database.AddSession which will trigger the result defined by the following
// Then helper
func (mmAddSession *mDatabaseMockAddSession) When(ctx context.Context, tournamentID int64, chatID int64) *DatabaseMockAddSessionExpectation {
	if mmAddSession.mock.funcAddSession != nil {
		mmAddSession.mock.t.Fatalf("DatabaseMock.AddSession mock is already set by Set")
	}

	expectation := &DatabaseMockAddSessionExpectation{
		mock:   mmAddSession.mock,
		params: &DatabaseMockAddSessionParams{ctx, tournamentID, chatID},
	}
	mmAddSession.expectations = append(mmAddSession.expectations, expectation)
	return expectation
}

// Then sets up Database.AddSession return parameters for the expectation previously defined by the When method
func (e *DatabaseMockAddSessionExpectation) Then(err error) *DatabaseMock {
	e.results = &DatabaseMockAddSessionResults{err}
	return e.mock
}

// AddSession implements Database
func (mmAddSession *DatabaseMock) AddSession(ctx context.Context, tournamentID int64, chatID int64) (err error) {
	mm_atomic.AddUint64(&mmAddSession.beforeAddSessionCounter, 1)
	defer mm_atomic.AddUint64(&mmAddSession.afterAddSessionCounter, 1)

	if mmAddSession.inspectFuncAddSession != nil {
		mmAddSession.inspectFuncAddSession(ctx, tournamentID, chatID)
	}

	mm_params := &DatabaseMockAddSessionParams{ctx, tournamentID, chatID}

	// Record call args
	mmAddSession.AddSessionMock.mutex.Lock()
	mmAddSession.AddSessionMock.callArgs = append(mmAddSession.AddSessionMock.callArgs, mm_params)
	mmAddSession.AddSessionMock.mutex.Unlock()

	for _, e := range mmAddSession.AddSessionMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddSession.AddSessionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddSession.AddSessionMock.defaultExpectation.Counter, 1)
		mm_want := mmAddSession.AddSessionMock.defaultExpectation.params
		mm_got := DatabaseMockAddSessionParams{ctx, tournamentID, chatID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddSession.t.Errorf("DatabaseMock.AddSession got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddSession.AddSessionMock.defaultExpectation.results
		if mm_results == nil {
			mmAddSession.t.Fatal("No results are set for the DatabaseMock.AddSession")
		}
		return (*mm_results).err
	}
	if mmAddSession.funcAddSession != nil {
		return mmAddSession.funcAddSession(ctx, tournamentID, chatID)
	}
	mmAddSession.t.Fatalf("Unexpected call to DatabaseMock.AddSession. %v %v %v", ctx, tournamentID, chatID)
	return
}

// AddSessionAfterCounter returns a count of finished DatabaseMock.AddSession invocations
func (mmAddSession *DatabaseMock) AddSessionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddSession.afterAddSessionCounter)
}

// AddSessionBeforeCounter returns a count of DatabaseMock.AddSession invocations
func (mmAddSession *DatabaseMock) AddSessionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddSession.beforeAddSessionCounter)
}

// Calls returns a list of arguments used in each call to DatabaseMock.AddSession.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddSession *mDatabaseMockAddSession) Calls() []*DatabaseMockAddSessionParams {
	mmAddSession.mutex.RLock()

	argCopy := make([]*DatabaseMockAddSessionParams, len(mmAddSession.callArgs))
	copy(argCopy, mmAddSession.callArgs)

	mmAddSession.mutex.RUnlock()

	return argCopy
}

// MinimockAddSessionDone returns true if the count of the AddSession invocations corresponds
// the number of defined expectations
func (m *DatabaseMock) MinimockAddSessionDone() bool {
	for _, e := range m.AddSessionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddSessionMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddSessionCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddSession != nil && mm_atomic.LoadUint64(&m.afterAddSessionCounter) < 1 {
		return false
	}
	return true
}

// MinimockAddSessionInspect logs each unmet expectation
func (m *DatabaseMock) MinimockAddSessionInspect() {
	for _, e := range m.AddSessionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DatabaseMock.AddSession with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddSessionMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddSessionCounter) < 1 {
		if m.AddSessionMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to DatabaseMock.AddSession")
		} else {
			m.t.Errorf("Expected call to DatabaseMock.AddSession with params: %#v", *m.AddSessionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddSession != nil && mm_atomic.LoadUint64(&m.afterAddSessionCounter) < 1 {
		m.t.Error("Expected call to DatabaseMock.AddSession")
	}
}

type mDatabaseMockAddTournament struct {
	mock               *DatabaseMock
	defaultExpectation *DatabaseMockAddTournamentExpectation
	expectations       []*DatabaseMockAddTournamentExpectation

	callArgs []*DatabaseMockAddTournamentParams
	mutex    sync.RWMutex
}

// DatabaseMockAddTournamentExpectation specifies expectation struct of the Database.AddTournament
type DatabaseMockAddTournamentExpectation struct {
	mock    *DatabaseMock
	params  *DatabaseMockAddTournamentParams
	results *DatabaseMockAddTournamentResults
	Counter uint64
}

// DatabaseMockAddTournamentParams contains parameters of the Database.AddTournament
type DatabaseMockAddTournamentParams struct {
	ctx        context.Context
	tournament models.Tournament
	tours      []models.Tour
}

// DatabaseMockAddTournamentResults contains results of the Database.AddTournament
type DatabaseMockAddTournamentResults struct {
	err error
}

// Expect sets up expected params for Database.AddTournament
func (mmAddTournament *mDatabaseMockAddTournament) Expect(ctx context.Context, tournament models.Tournament, tours []models.Tour) *mDatabaseMockAddTournament {
	if mmAddTournament.mock.funcAddTournament != nil {
		mmAddTournament.mock.t.Fatalf("DatabaseMock.AddTournament mock is already set by Set")
	}

	if mmAddTournament.defaultExpectation == nil {
		mmAddTournament.defaultExpectation = &DatabaseMockAddTournamentExpectation{}
	}

	mmAddTournament.defaultExpectation.params = &DatabaseMockAddTournamentParams{ctx, tournament, tours}
	for _, e := range mmAddTournament.expectations {
		if minimock.Equal(e.params, mmAddTournament.defaultExpectation.params) {
			mmAddTournament.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddTournament.defaultExpectation.params)
		}
	}

	return mmAddTournament
}

// Inspect accepts an inspector function that has same arguments as the Database.AddTournament
func (mmAddTournament *mDatabaseMockAddTournament) Inspect(f func(ctx context.Context, tournament models.Tournament, tours []models.Tour)) *mDatabaseMockAddTournament {
	if mmAddTournament.mock.inspectFuncAddTournament != nil {
		mmAddTournament.mock.t.Fatalf("Inspect function is already set for DatabaseMock.AddTournament")
	}

	mmAddTournament.mock.inspectFuncAddTournament = f

	return mmAddTournament
}

// Return sets up results that will be returned by Database.AddTournament
func (mmAddTournament *mDatabaseMockAddTournament) Return(err error) *DatabaseMock {
	if mmAddTournament.mock.funcAddTournament != nil {
		mmAddTournament.mock.t.Fatalf("DatabaseMock.AddTournament mock is already set by Set")
	}

	if mmAddTournament.defaultExpectation == nil {
		mmAddTournament.defaultExpectation = &DatabaseMockAddTournamentExpectation{mock: mmAddTournament.mock}
	}
	mmAddTournament.defaultExpectation.results = &DatabaseMockAddTournamentResults{err}
	return mmAddTournament.mock
}

//Set uses given function f to mock the Database.AddTournament method
func (mmAddTournament *mDatabaseMockAddTournament) Set(f func(ctx context.Context, tournament models.Tournament, tours []models.Tour) (err error)) *DatabaseMock {
	if mmAddTournament.defaultExpectation != nil {
		mmAddTournament.mock.t.Fatalf("Default expectation is already set for the Database.AddTournament method")
	}

	if len(mmAddTournament.expectations) > 0 {
		mmAddTournament.mock.t.Fatalf("Some expectations are already set for the Database.AddTournament method")
	}

	mmAddTournament.mock.funcAddTournament = f
	return mmAddTournament.mock
}

// When sets expectation for the Database.AddTournament which will trigger the result defined by the following
// Then helper
func (mmAddTournament *mDatabaseMockAddTournament) When(ctx context.Context, tournament models.Tournament, tours []models.Tour) *DatabaseMockAddTournamentExpectation {
	if mmAddTournament.mock.funcAddTournament != nil {
		mmAddTournament.mock.t.Fatalf("DatabaseMock.AddTournament mock is already set by Set")
	}

	expectation := &DatabaseMockAddTournamentExpectation{
		mock:   mmAddTournament.mock,
		params: &DatabaseMockAddTournamentParams{ctx, tournament, tours},
	}
	mmAddTournament.expectations = append(mmAddTournament.expectations, expectation)
	return expectation
}

// Then sets up Database.AddTournament return parameters for the expectation previously defined by the When method
func (e *DatabaseMockAddTournamentExpectation) Then(err error) *DatabaseMock {
	e.results = &DatabaseMockAddTournamentResults{err}
	return e.mock
}

// AddTournament implements Database
func (mmAddTournament *DatabaseMock) AddTournament(ctx context.Context, tournament models.Tournament, tours []models.Tour) (err error) {
	mm_atomic.AddUint64(&mmAddTournament.beforeAddTournamentCounter, 1)
	defer mm_atomic.AddUint64(&mmAddTournament.afterAddTournamentCounter, 1)

	if mmAddTournament.inspectFuncAddTournament != nil {
		mmAddTournament.inspectFuncAddTournament(ctx, tournament, tours)
	}

	mm_params := &DatabaseMockAddTournamentParams{ctx, tournament, tours}

	// Record call args
	mmAddTournament.AddTournamentMock.mutex.Lock()
	mmAddTournament.AddTournamentMock.callArgs = append(mmAddTournament.AddTournamentMock.callArgs, mm_params)
	mmAddTournament.AddTournamentMock.mutex.Unlock()

	for _, e := range mmAddTournament.AddTournamentMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddTournament.AddTournamentMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddTournament.AddTournamentMock.defaultExpectation.Counter, 1)
		mm_want := mmAddTournament.AddTournamentMock.defaultExpectation.params
		mm_got := DatabaseMockAddTournamentParams{ctx, tournament, tours}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddTournament.t.Errorf("DatabaseMock.AddTournament got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddTournament.AddTournamentMock.defaultExpectation.results
		if mm_results == nil {
			mmAddTournament.t.Fatal("No results are set for the DatabaseMock.AddTournament")
		}
		return (*mm_results).err
	}
	if mmAddTournament.funcAddTournament != nil {
		return mmAddTournament.funcAddTournament(ctx, tournament, tours)
	}
	mmAddTournament.t.Fatalf("Unexpected call to DatabaseMock.AddTournament. %v %v %v", ctx, tournament, tours)
	return
}

// AddTournamentAfterCounter returns a count of finished DatabaseMock.AddTournament invocations
func (mmAddTournament *DatabaseMock) AddTournamentAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddTournament.afterAddTournamentCounter)
}

// AddTournamentBeforeCounter returns a count of DatabaseMock.AddTournament invocations
func (mmAddTournament *DatabaseMock) AddTournamentBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddTournament.beforeAddTournamentCounter)
}

// Calls returns a list of arguments used in each call to DatabaseMock.AddTournament.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddTournament *mDatabaseMockAddTournament) Calls() []*DatabaseMockAddTournamentParams {
	mmAddTournament.mutex.RLock()

	argCopy := make([]*DatabaseMockAddTournamentParams, len(mmAddTournament.callArgs))
	copy(argCopy, mmAddTournament.callArgs)

	mmAddTournament.mutex.RUnlock()

	return argCopy
}

// MinimockAddTournamentDone returns true if the count of the AddTournament invocations corresponds
// the number of defined expectations
func (m *DatabaseMock) MinimockAddTournamentDone() bool {
	for _, e := range m.AddTournamentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddTournamentMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddTournamentCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddTournament != nil && mm_atomic.LoadUint64(&m.afterAddTournamentCounter) < 1 {
		return false
	}
	return true
}

// MinimockAddTournamentInspect logs each unmet expectation
func (m *DatabaseMock) MinimockAddTournamentInspect() {
	for _, e := range m.AddTournamentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DatabaseMock.AddTournament with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddTournamentMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddTournamentCounter) < 1 {
		if m.AddTournamentMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to DatabaseMock.AddTournament")
		} else {
			m.t.Errorf("Expected call to DatabaseMock.AddTournament with params: %#v", *m.AddTournamentMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddTournament != nil && mm_atomic.LoadUint64(&m.afterAddTournamentCounter) < 1 {
		m.t.Error("Expected call to DatabaseMock.AddTournament")
	}
}

type mDatabaseMockFetchQuestion struct {
	mock               *DatabaseMock
	defaultExpectation *DatabaseMockFetchQuestionExpectation
	expectations       []*DatabaseMockFetchQuestionExpectation

	callArgs []*DatabaseMockFetchQuestionParams
	mutex    sync.RWMutex
}

// DatabaseMockFetchQuestionExpectation specifies expectation struct of the Database.FetchQuestion
type DatabaseMockFetchQuestionExpectation struct {
	mock    *DatabaseMock
	params  *DatabaseMockFetchQuestionParams
	results *DatabaseMockFetchQuestionResults
	Counter uint64
}

// DatabaseMockFetchQuestionParams contains parameters of the Database.FetchQuestion
type DatabaseMockFetchQuestionParams struct {
	ctx        context.Context
	questionID int64
}

// DatabaseMockFetchQuestionResults contains results of the Database.FetchQuestion
type DatabaseMockFetchQuestionResults struct {
	q1  models.Question
	err error
}

// Expect sets up expected params for Database.FetchQuestion
func (mmFetchQuestion *mDatabaseMockFetchQuestion) Expect(ctx context.Context, questionID int64) *mDatabaseMockFetchQuestion {
	if mmFetchQuestion.mock.funcFetchQuestion != nil {
		mmFetchQuestion.mock.t.Fatalf("DatabaseMock.FetchQuestion mock is already set by Set")
	}

	if mmFetchQuestion.defaultExpectation == nil {
		mmFetchQuestion.defaultExpectation = &DatabaseMockFetchQuestionExpectation{}
	}

	mmFetchQuestion.defaultExpectation.params = &DatabaseMockFetchQuestionParams{ctx, questionID}
	for _, e := range mmFetchQuestion.expectations {
		if minimock.Equal(e.params, mmFetchQuestion.defaultExpectation.params) {
			mmFetchQuestion.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmFetchQuestion.defaultExpectation.params)
		}
	}

	return mmFetchQuestion
}

// Inspect accepts an inspector function that has same arguments as the Database.FetchQuestion
func (mmFetchQuestion *mDatabaseMockFetchQuestion) Inspect(f func(ctx context.Context, questionID int64)) *mDatabaseMockFetchQuestion {
	if mmFetchQuestion.mock.inspectFuncFetchQuestion != nil {
		mmFetchQuestion.mock.t.Fatalf("Inspect function is already set for DatabaseMock.FetchQuestion")
	}

	mmFetchQuestion.mock.inspectFuncFetchQuestion = f

	return mmFetchQuestion
}

// Return sets up results that will be returned by Database.FetchQuestion
func (mmFetchQuestion *mDatabaseMockFetchQuestion) Return(q1 models.Question, err error) *DatabaseMock {
	if mmFetchQuestion.mock.funcFetchQuestion != nil {
		mmFetchQuestion.mock.t.Fatalf("DatabaseMock.FetchQuestion mock is already set by Set")
	}

	if mmFetchQuestion.defaultExpectation == nil {
		mmFetchQuestion.defaultExpectation = &DatabaseMockFetchQuestionExpectation{mock: mmFetchQuestion.mock}
	}
	mmFetchQuestion.defaultExpectation.results = &DatabaseMockFetchQuestionResults{q1, err}
	return mmFetchQuestion.mock
}

//Set uses given function f to mock the Database.FetchQuestion method
func (mmFetchQuestion *mDatabaseMockFetchQuestion) Set(f func(ctx context.Context, questionID int64) (q1 models.Question, err error)) *DatabaseMock {
	if mmFetchQuestion.defaultExpectation != nil {
		mmFetchQuestion.mock.t.Fatalf("Default expectation is already set for the Database.FetchQuestion method")
	}

	if len(mmFetchQuestion.expectations) > 0 {
		mmFetchQuestion.mock.t.Fatalf("Some expectations are already set for the Database.FetchQuestion method")
	}

	mmFetchQuestion.mock.funcFetchQuestion = f
	return mmFetchQuestion.mock
}

// When sets expectation for the Database.FetchQuestion which will trigger the result defined by the following
// Then helper
func (mmFetchQuestion *mDatabaseMockFetchQuestion) When(ctx context.Context, questionID int64) *DatabaseMockFetchQuestionExpectation {
	if mmFetchQuestion.mock.funcFetchQuestion != nil {
		mmFetchQuestion.mock.t.Fatalf("DatabaseMock.FetchQuestion mock is already set by Set")
	}

	expectation := &DatabaseMockFetchQuestionExpectation{
		mock:   mmFetchQuestion.mock,
		params: &DatabaseMockFetchQuestionParams{ctx, questionID},
	}
	mmFetchQuestion.expectations = append(mmFetchQuestion.expectations, expectation)
	return expectation
}

// Then sets up Database.FetchQuestion return parameters for the expectation previously defined by the When method
func (e *DatabaseMockFetchQuestionExpectation) Then(q1 models.Question, err error) *DatabaseMock {
	e.results = &DatabaseMockFetchQuestionResults{q1, err}
	return e.mock
}

// FetchQuestion implements Database
func (mmFetchQuestion *DatabaseMock) FetchQuestion(ctx context.Context, questionID int64) (q1 models.Question, err error) {
	mm_atomic.AddUint64(&mmFetchQuestion.beforeFetchQuestionCounter, 1)
	defer mm_atomic.AddUint64(&mmFetchQuestion.afterFetchQuestionCounter, 1)

	if mmFetchQuestion.inspectFuncFetchQuestion != nil {
		mmFetchQuestion.inspectFuncFetchQuestion(ctx, questionID)
	}

	mm_params := &DatabaseMockFetchQuestionParams{ctx, questionID}

	// Record call args
	mmFetchQuestion.FetchQuestionMock.mutex.Lock()
	mmFetchQuestion.FetchQuestionMock.callArgs = append(mmFetchQuestion.FetchQuestionMock.callArgs, mm_params)
	mmFetchQuestion.FetchQuestionMock.mutex.Unlock()

	for _, e := range mmFetchQuestion.FetchQuestionMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.q1, e.results.err
		}
	}

	if mmFetchQuestion.FetchQuestionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFetchQuestion.FetchQuestionMock.defaultExpectation.Counter, 1)
		mm_want := mmFetchQuestion.FetchQuestionMock.defaultExpectation.params
		mm_got := DatabaseMockFetchQuestionParams{ctx, questionID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmFetchQuestion.t.Errorf("DatabaseMock.FetchQuestion got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmFetchQuestion.FetchQuestionMock.defaultExpectation.results
		if mm_results == nil {
			mmFetchQuestion.t.Fatal("No results are set for the DatabaseMock.FetchQuestion")
		}
		return (*mm_results).q1, (*mm_results).err
	}
	if mmFetchQuestion.funcFetchQuestion != nil {
		return mmFetchQuestion.funcFetchQuestion(ctx, questionID)
	}
	mmFetchQuestion.t.Fatalf("Unexpected call to DatabaseMock.FetchQuestion. %v %v", ctx, questionID)
	return
}

// FetchQuestionAfterCounter returns a count of finished DatabaseMock.FetchQuestion invocations
func (mmFetchQuestion *DatabaseMock) FetchQuestionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFetchQuestion.afterFetchQuestionCounter)
}

// FetchQuestionBeforeCounter returns a count of DatabaseMock.FetchQuestion invocations
func (mmFetchQuestion *DatabaseMock) FetchQuestionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFetchQuestion.beforeFetchQuestionCounter)
}

// Calls returns a list of arguments used in each call to DatabaseMock.FetchQuestion.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmFetchQuestion *mDatabaseMockFetchQuestion) Calls() []*DatabaseMockFetchQuestionParams {
	mmFetchQuestion.mutex.RLock()

	argCopy := make([]*DatabaseMockFetchQuestionParams, len(mmFetchQuestion.callArgs))
	copy(argCopy, mmFetchQuestion.callArgs)

	mmFetchQuestion.mutex.RUnlock()

	return argCopy
}

// MinimockFetchQuestionDone returns true if the count of the FetchQuestion invocations corresponds
// the number of defined expectations
func (m *DatabaseMock) MinimockFetchQuestionDone() bool {
	for _, e := range m.FetchQuestionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FetchQuestionMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFetchQuestionCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFetchQuestion != nil && mm_atomic.LoadUint64(&m.afterFetchQuestionCounter) < 1 {
		return false
	}
	return true
}

// MinimockFetchQuestionInspect logs each unmet expectation
func (m *DatabaseMock) MinimockFetchQuestionInspect() {
	for _, e := range m.FetchQuestionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DatabaseMock.FetchQuestion with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FetchQuestionMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFetchQuestionCounter) < 1 {
		if m.FetchQuestionMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to DatabaseMock.FetchQuestion")
		} else {
			m.t.Errorf("Expected call to DatabaseMock.FetchQuestion with params: %#v", *m.FetchQuestionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFetchQuestion != nil && mm_atomic.LoadUint64(&m.afterFetchQuestionCounter) < 1 {
		m.t.Error("Expected call to DatabaseMock.FetchQuestion")
	}
}

type mDatabaseMockFetchQuestions struct {
	mock               *DatabaseMock
	defaultExpectation *DatabaseMockFetchQuestionsExpectation
	expectations       []*DatabaseMockFetchQuestionsExpectation

	callArgs []*DatabaseMockFetchQuestionsParams
	mutex    sync.RWMutex
}

// DatabaseMockFetchQuestionsExpectation specifies expectation struct of the Database.FetchQuestions
type DatabaseMockFetchQuestionsExpectation struct {
	mock    *DatabaseMock
	params  *DatabaseMockFetchQuestionsParams
	results *DatabaseMockFetchQuestionsResults
	Counter uint64
}

// DatabaseMockFetchQuestionsParams contains parameters of the Database.FetchQuestions
type DatabaseMockFetchQuestionsParams struct {
	ctx          context.Context
	tournamentID int64
}

// DatabaseMockFetchQuestionsResults contains results of the Database.FetchQuestions
type DatabaseMockFetchQuestionsResults struct {
	questions []int64
	err       error
}

// Expect sets up expected params for Database.FetchQuestions
func (mmFetchQuestions *mDatabaseMockFetchQuestions) Expect(ctx context.Context, tournamentID int64) *mDatabaseMockFetchQuestions {
	if mmFetchQuestions.mock.funcFetchQuestions != nil {
		mmFetchQuestions.mock.t.Fatalf("DatabaseMock.FetchQuestions mock is already set by Set")
	}

	if mmFetchQuestions.defaultExpectation == nil {
		mmFetchQuestions.defaultExpectation = &DatabaseMockFetchQuestionsExpectation{}
	}

	mmFetchQuestions.defaultExpectation.params = &DatabaseMockFetchQuestionsParams{ctx, tournamentID}
	for _, e := range mmFetchQuestions.expectations {
		if minimock.Equal(e.params, mmFetchQuestions.defaultExpectation.params) {
			mmFetchQuestions.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmFetchQuestions.defaultExpectation.params)
		}
	}

	return mmFetchQuestions
}

// Inspect accepts an inspector function that has same arguments as the Database.FetchQuestions
func (mmFetchQuestions *mDatabaseMockFetchQuestions) Inspect(f func(ctx context.Context, tournamentID int64)) *mDatabaseMockFetchQuestions {
	if mmFetchQuestions.mock.inspectFuncFetchQuestions != nil {
		mmFetchQuestions.mock.t.Fatalf("Inspect function is already set for DatabaseMock.FetchQuestions")
	}

	mmFetchQuestions.mock.inspectFuncFetchQuestions = f

	return mmFetchQuestions
}

// Return sets up results that will be returned by Database.FetchQuestions
func (mmFetchQuestions *mDatabaseMockFetchQuestions) Return(questions []int64, err error) *DatabaseMock {
	if mmFetchQuestions.mock.funcFetchQuestions != nil {
		mmFetchQuestions.mock.t.Fatalf("DatabaseMock.FetchQuestions mock is already set by Set")
	}

	if mmFetchQuestions.defaultExpectation == nil {
		mmFetchQuestions.defaultExpectation = &DatabaseMockFetchQuestionsExpectation{mock: mmFetchQuestions.mock}
	}
	mmFetchQuestions.defaultExpectation.results = &DatabaseMockFetchQuestionsResults{questions, err}
	return mmFetchQuestions.mock
}

//Set uses given function f to mock the Database.FetchQuestions method
func (mmFetchQuestions *mDatabaseMockFetchQuestions) Set(f func(ctx context.Context, tournamentID int64) (questions []int64, err error)) *DatabaseMock {
	if mmFetchQuestions.defaultExpectation != nil {
		mmFetchQuestions.mock.t.Fatalf("Default expectation is already set for the Database.FetchQuestions method")
	}

	if len(mmFetchQuestions.expectations) > 0 {
		mmFetchQuestions.mock.t.Fatalf("Some expectations are already set for the Database.FetchQuestions method")
	}

	mmFetchQuestions.mock.funcFetchQuestions = f
	return mmFetchQuestions.mock
}

// When sets expectation for the Database.FetchQuestions which will trigger the result defined by the following
// Then helper
func (mmFetchQuestions *mDatabaseMockFetchQuestions) When(ctx context.Context, tournamentID int64) *DatabaseMockFetchQuestionsExpectation {
	if mmFetchQuestions.mock.funcFetchQuestions != nil {
		mmFetchQuestions.mock.t.Fatalf("DatabaseMock.FetchQuestions mock is already set by Set")
	}

	expectation := &DatabaseMockFetchQuestionsExpectation{
		mock:   mmFetchQuestions.mock,
		params: &DatabaseMockFetchQuestionsParams{ctx, tournamentID},
	}
	mmFetchQuestions.expectations = append(mmFetchQuestions.expectations, expectation)
	return expectation
}

// Then sets up Database.FetchQuestions return parameters for the expectation previously defined by the When method
func (e *DatabaseMockFetchQuestionsExpectation) Then(questions []int64, err error) *DatabaseMock {
	e.results = &DatabaseMockFetchQuestionsResults{questions, err}
	return e.mock
}

// FetchQuestions implements Database
func (mmFetchQuestions *DatabaseMock) FetchQuestions(ctx context.Context, tournamentID int64) (questions []int64, err error) {
	mm_atomic.AddUint64(&mmFetchQuestions.beforeFetchQuestionsCounter, 1)
	defer mm_atomic.AddUint64(&mmFetchQuestions.afterFetchQuestionsCounter, 1)

	if mmFetchQuestions.inspectFuncFetchQuestions != nil {
		mmFetchQuestions.inspectFuncFetchQuestions(ctx, tournamentID)
	}

	mm_params := &DatabaseMockFetchQuestionsParams{ctx, tournamentID}

	// Record call args
	mmFetchQuestions.FetchQuestionsMock.mutex.Lock()
	mmFetchQuestions.FetchQuestionsMock.callArgs = append(mmFetchQuestions.FetchQuestionsMock.callArgs, mm_params)
	mmFetchQuestions.FetchQuestionsMock.mutex.Unlock()

	for _, e := range mmFetchQuestions.FetchQuestionsMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.questions, e.results.err
		}
	}

	if mmFetchQuestions.FetchQuestionsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFetchQuestions.FetchQuestionsMock.defaultExpectation.Counter, 1)
		mm_want := mmFetchQuestions.FetchQuestionsMock.defaultExpectation.params
		mm_got := DatabaseMockFetchQuestionsParams{ctx, tournamentID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmFetchQuestions.t.Errorf("DatabaseMock.FetchQuestions got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmFetchQuestions.FetchQuestionsMock.defaultExpectation.results
		if mm_results == nil {
			mmFetchQuestions.t.Fatal("No results are set for the DatabaseMock.FetchQuestions")
		}
		return (*mm_results).questions, (*mm_results).err
	}
	if mmFetchQuestions.funcFetchQuestions != nil {
		return mmFetchQuestions.funcFetchQuestions(ctx, tournamentID)
	}
	mmFetchQuestions.t.Fatalf("Unexpected call to DatabaseMock.FetchQuestions. %v %v", ctx, tournamentID)
	return
}

// FetchQuestionsAfterCounter returns a count of finished DatabaseMock.FetchQuestions invocations
func (mmFetchQuestions *DatabaseMock) FetchQuestionsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFetchQuestions.afterFetchQuestionsCounter)
}

// FetchQuestionsBeforeCounter returns a count of DatabaseMock.FetchQuestions invocations
func (mmFetchQuestions *DatabaseMock) FetchQuestionsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFetchQuestions.beforeFetchQuestionsCounter)
}

// Calls returns a list of arguments used in each call to DatabaseMock.FetchQuestions.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmFetchQuestions *mDatabaseMockFetchQuestions) Calls() []*DatabaseMockFetchQuestionsParams {
	mmFetchQuestions.mutex.RLock()

	argCopy := make([]*DatabaseMockFetchQuestionsParams, len(mmFetchQuestions.callArgs))
	copy(argCopy, mmFetchQuestions.callArgs)

	mmFetchQuestions.mutex.RUnlock()

	return argCopy
}

// MinimockFetchQuestionsDone returns true if the count of the FetchQuestions invocations corresponds
// the number of defined expectations
func (m *DatabaseMock) MinimockFetchQuestionsDone() bool {
	for _, e := range m.FetchQuestionsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FetchQuestionsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFetchQuestionsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFetchQuestions != nil && mm_atomic.LoadUint64(&m.afterFetchQuestionsCounter) < 1 {
		return false
	}
	return true
}

// MinimockFetchQuestionsInspect logs each unmet expectation
func (m *DatabaseMock) MinimockFetchQuestionsInspect() {
	for _, e := range m.FetchQuestionsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DatabaseMock.FetchQuestions with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FetchQuestionsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFetchQuestionsCounter) < 1 {
		if m.FetchQuestionsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to DatabaseMock.FetchQuestions")
		} else {
			m.t.Errorf("Expected call to DatabaseMock.FetchQuestions with params: %#v", *m.FetchQuestionsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFetchQuestions != nil && mm_atomic.LoadUint64(&m.afterFetchQuestionsCounter) < 1 {
		m.t.Error("Expected call to DatabaseMock.FetchQuestions")
	}
}

type mDatabaseMockFetchScore struct {
	mock               *DatabaseMock
	defaultExpectation *DatabaseMockFetchScoreExpectation
	expectations       []*DatabaseMockFetchScoreExpectation

	callArgs []*DatabaseMockFetchScoreParams
	mutex    sync.RWMutex
}

// DatabaseMockFetchScoreExpectation specifies expectation struct of the Database.FetchScore
type DatabaseMockFetchScoreExpectation struct {
	mock    *DatabaseMock
	params  *DatabaseMockFetchScoreParams
	results *DatabaseMockFetchScoreResults
	Counter uint64
}

// DatabaseMockFetchScoreParams contains parameters of the Database.FetchScore
type DatabaseMockFetchScoreParams struct {
	ctx    context.Context
	chatID int64
}

// DatabaseMockFetchScoreResults contains results of the Database.FetchScore
type DatabaseMockFetchScoreResults struct {
	ua1 []models.User
	err error
}

// Expect sets up expected params for Database.FetchScore
func (mmFetchScore *mDatabaseMockFetchScore) Expect(ctx context.Context, chatID int64) *mDatabaseMockFetchScore {
	if mmFetchScore.mock.funcFetchScore != nil {
		mmFetchScore.mock.t.Fatalf("DatabaseMock.FetchScore mock is already set by Set")
	}

	if mmFetchScore.defaultExpectation == nil {
		mmFetchScore.defaultExpectation = &DatabaseMockFetchScoreExpectation{}
	}

	mmFetchScore.defaultExpectation.params = &DatabaseMockFetchScoreParams{ctx, chatID}
	for _, e := range mmFetchScore.expectations {
		if minimock.Equal(e.params, mmFetchScore.defaultExpectation.params) {
			mmFetchScore.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmFetchScore.defaultExpectation.params)
		}
	}

	return mmFetchScore
}

// Inspect accepts an inspector function that has same arguments as the Database.FetchScore
func (mmFetchScore *mDatabaseMockFetchScore) Inspect(f func(ctx context.Context, chatID int64)) *mDatabaseMockFetchScore {
	if mmFetchScore.mock.inspectFuncFetchScore != nil {
		mmFetchScore.mock.t.Fatalf("Inspect function is already set for DatabaseMock.FetchScore")
	}

	mmFetchScore.mock.inspectFuncFetchScore = f

	return mmFetchScore
}

// Return sets up results that will be returned by Database.FetchScore
func (mmFetchScore *mDatabaseMockFetchScore) Return(ua1 []models.User, err error) *DatabaseMock {
	if mmFetchScore.mock.funcFetchScore != nil {
		mmFetchScore.mock.t.Fatalf("DatabaseMock.FetchScore mock is already set by Set")
	}

	if mmFetchScore.defaultExpectation == nil {
		mmFetchScore.defaultExpectation = &DatabaseMockFetchScoreExpectation{mock: mmFetchScore.mock}
	}
	mmFetchScore.defaultExpectation.results = &DatabaseMockFetchScoreResults{ua1, err}
	return mmFetchScore.mock
}

//Set uses given function f to mock the Database.FetchScore method
func (mmFetchScore *mDatabaseMockFetchScore) Set(f func(ctx context.Context, chatID int64) (ua1 []models.User, err error)) *DatabaseMock {
	if mmFetchScore.defaultExpectation != nil {
		mmFetchScore.mock.t.Fatalf("Default expectation is already set for the Database.FetchScore method")
	}

	if len(mmFetchScore.expectations) > 0 {
		mmFetchScore.mock.t.Fatalf("Some expectations are already set for the Database.FetchScore method")
	}

	mmFetchScore.mock.funcFetchScore = f
	return mmFetchScore.mock
}

// When sets expectation for the Database.FetchScore which will trigger the result defined by the following
// Then helper
func (mmFetchScore *mDatabaseMockFetchScore) When(ctx context.Context, chatID int64) *DatabaseMockFetchScoreExpectation {
	if mmFetchScore.mock.funcFetchScore != nil {
		mmFetchScore.mock.t.Fatalf("DatabaseMock.FetchScore mock is already set by Set")
	}

	expectation := &DatabaseMockFetchScoreExpectation{
		mock:   mmFetchScore.mock,
		params: &DatabaseMockFetchScoreParams{ctx, chatID},
	}
	mmFetchScore.expectations = append(mmFetchScore.expectations, expectation)
	return expectation
}

// Then sets up Database.FetchScore return parameters for the expectation previously defined by the When method
func (e *DatabaseMockFetchScoreExpectation) Then(ua1 []models.User, err error) *DatabaseMock {
	e.results = &DatabaseMockFetchScoreResults{ua1, err}
	return e.mock
}

// FetchScore implements Database
func (mmFetchScore *DatabaseMock) FetchScore(ctx context.Context, chatID int64) (ua1 []models.User, err error) {
	mm_atomic.AddUint64(&mmFetchScore.beforeFetchScoreCounter, 1)
	defer mm_atomic.AddUint64(&mmFetchScore.afterFetchScoreCounter, 1)

	if mmFetchScore.inspectFuncFetchScore != nil {
		mmFetchScore.inspectFuncFetchScore(ctx, chatID)
	}

	mm_params := &DatabaseMockFetchScoreParams{ctx, chatID}

	// Record call args
	mmFetchScore.FetchScoreMock.mutex.Lock()
	mmFetchScore.FetchScoreMock.callArgs = append(mmFetchScore.FetchScoreMock.callArgs, mm_params)
	mmFetchScore.FetchScoreMock.mutex.Unlock()

	for _, e := range mmFetchScore.FetchScoreMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ua1, e.results.err
		}
	}

	if mmFetchScore.FetchScoreMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFetchScore.FetchScoreMock.defaultExpectation.Counter, 1)
		mm_want := mmFetchScore.FetchScoreMock.defaultExpectation.params
		mm_got := DatabaseMockFetchScoreParams{ctx, chatID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmFetchScore.t.Errorf("DatabaseMock.FetchScore got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmFetchScore.FetchScoreMock.defaultExpectation.results
		if mm_results == nil {
			mmFetchScore.t.Fatal("No results are set for the DatabaseMock.FetchScore")
		}
		return (*mm_results).ua1, (*mm_results).err
	}
	if mmFetchScore.funcFetchScore != nil {
		return mmFetchScore.funcFetchScore(ctx, chatID)
	}
	mmFetchScore.t.Fatalf("Unexpected call to DatabaseMock.FetchScore. %v %v", ctx, chatID)
	return
}

// FetchScoreAfterCounter returns a count of finished DatabaseMock.FetchScore invocations
func (mmFetchScore *DatabaseMock) FetchScoreAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFetchScore.afterFetchScoreCounter)
}

// FetchScoreBeforeCounter returns a count of DatabaseMock.FetchScore invocations
func (mmFetchScore *DatabaseMock) FetchScoreBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFetchScore.beforeFetchScoreCounter)
}

// Calls returns a list of arguments used in each call to DatabaseMock.FetchScore.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmFetchScore *mDatabaseMockFetchScore) Calls() []*DatabaseMockFetchScoreParams {
	mmFetchScore.mutex.RLock()

	argCopy := make([]*DatabaseMockFetchScoreParams, len(mmFetchScore.callArgs))
	copy(argCopy, mmFetchScore.callArgs)

	mmFetchScore.mutex.RUnlock()

	return argCopy
}

// MinimockFetchScoreDone returns true if the count of the FetchScore invocations corresponds
// the number of defined expectations
func (m *DatabaseMock) MinimockFetchScoreDone() bool {
	for _, e := range m.FetchScoreMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FetchScoreMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFetchScoreCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFetchScore != nil && mm_atomic.LoadUint64(&m.afterFetchScoreCounter) < 1 {
		return false
	}
	return true
}

// MinimockFetchScoreInspect logs each unmet expectation
func (m *DatabaseMock) MinimockFetchScoreInspect() {
	for _, e := range m.FetchScoreMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DatabaseMock.FetchScore with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FetchScoreMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFetchScoreCounter) < 1 {
		if m.FetchScoreMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to DatabaseMock.FetchScore")
		} else {
			m.t.Errorf("Expected call to DatabaseMock.FetchScore with params: %#v", *m.FetchScoreMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFetchScore != nil && mm_atomic.LoadUint64(&m.afterFetchScoreCounter) < 1 {
		m.t.Error("Expected call to DatabaseMock.FetchScore")
	}
}

type mDatabaseMockFetchSessions struct {
	mock               *DatabaseMock
	defaultExpectation *DatabaseMockFetchSessionsExpectation
	expectations       []*DatabaseMockFetchSessionsExpectation

	callArgs []*DatabaseMockFetchSessionsParams
	mutex    sync.RWMutex
}

// DatabaseMockFetchSessionsExpectation specifies expectation struct of the Database.FetchSessions
type DatabaseMockFetchSessionsExpectation struct {
	mock    *DatabaseMock
	params  *DatabaseMockFetchSessionsParams
	results *DatabaseMockFetchSessionsResults
	Counter uint64
}

// DatabaseMockFetchSessionsParams contains parameters of the Database.FetchSessions
type DatabaseMockFetchSessionsParams struct {
	ctx    context.Context
	chatID int64
}

// DatabaseMockFetchSessionsResults contains results of the Database.FetchSessions
type DatabaseMockFetchSessionsResults struct {
	sa1 []models.Session
	err error
}

// Expect sets up expected params for Database.FetchSessions
func (mmFetchSessions *mDatabaseMockFetchSessions) Expect(ctx context.Context, chatID int64) *mDatabaseMockFetchSessions {
	if mmFetchSessions.mock.funcFetchSessions != nil {
		mmFetchSessions.mock.t.Fatalf("DatabaseMock.FetchSessions mock is already set by Set")
	}

	if mmFetchSessions.defaultExpectation == nil {
		mmFetchSessions.defaultExpectation = &DatabaseMockFetchSessionsExpectation{}
	}

	mmFetchSessions.defaultExpectation.params = &DatabaseMockFetchSessionsParams{ctx, chatID}
	for _, e := range mmFetchSessions.expectations {
		if minimock.Equal(e.params, mmFetchSessions.defaultExpectation.params) {
			mmFetchSessions.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmFetchSessions.defaultExpectation.params)
		}
	}

	return mmFetchSessions
}

// Inspect accepts an inspector function that has same arguments as the Database.FetchSessions
func (mmFetchSessions *mDatabaseMockFetchSessions) Inspect(f func(ctx context.Context, chatID int64)) *mDatabaseMockFetchSessions {
	if mmFetchSessions.mock.inspectFuncFetchSessions != nil {
		mmFetchSessions.mock.t.Fatalf("Inspect function is already set for DatabaseMock.FetchSessions")
	}

	mmFetchSessions.mock.inspectFuncFetchSessions = f

	return mmFetchSessions
}

// Return sets up results that will be returned by Database.FetchSessions
func (mmFetchSessions *mDatabaseMockFetchSessions) Return(sa1 []models.Session, err error) *DatabaseMock {
	if mmFetchSessions.mock.funcFetchSessions != nil {
		mmFetchSessions.mock.t.Fatalf("DatabaseMock.FetchSessions mock is already set by Set")
	}

	if mmFetchSessions.defaultExpectation == nil {
		mmFetchSessions.defaultExpectation = &DatabaseMockFetchSessionsExpectation{mock: mmFetchSessions.mock}
	}
	mmFetchSessions.defaultExpectation.results = &DatabaseMockFetchSessionsResults{sa1, err}
	return mmFetchSessions.mock
}

//Set uses given function f to mock the Database.FetchSessions method
func (mmFetchSessions *mDatabaseMockFetchSessions) Set(f func(ctx context.Context, chatID int64) (sa1 []models.Session, err error)) *DatabaseMock {
	if mmFetchSessions.defaultExpectation != nil {
		mmFetchSessions.mock.t.Fatalf("Default expectation is already set for the Database.FetchSessions method")
	}

	if len(mmFetchSessions.expectations) > 0 {
		mmFetchSessions.mock.t.Fatalf("Some expectations are already set for the Database.FetchSessions method")
	}

	mmFetchSessions.mock.funcFetchSessions = f
	return mmFetchSessions.mock
}

// When sets expectation for the Database.FetchSessions which will trigger the result defined by the following
// Then helper
func (mmFetchSessions *mDatabaseMockFetchSessions) When(ctx context.Context, chatID int64) *DatabaseMockFetchSessionsExpectation {
	if mmFetchSessions.mock.funcFetchSessions != nil {
		mmFetchSessions.mock.t.Fatalf("DatabaseMock.FetchSessions mock is already set by Set")
	}

	expectation := &DatabaseMockFetchSessionsExpectation{
		mock:   mmFetchSessions.mock,
		params: &DatabaseMockFetchSessionsParams{ctx, chatID},
	}
	mmFetchSessions.expectations = append(mmFetchSessions.expectations, expectation)
	return expectation
}

// Then sets up Database.FetchSessions return parameters for the expectation previously defined by the When method
func (e *DatabaseMockFetchSessionsExpectation) Then(sa1 []models.Session, err error) *DatabaseMock {
	e.results = &DatabaseMockFetchSessionsResults{sa1, err}
	return e.mock
}

// FetchSessions implements Database
func (mmFetchSessions *DatabaseMock) FetchSessions(ctx context.Context, chatID int64) (sa1 []models.Session, err error) {
	mm_atomic.AddUint64(&mmFetchSessions.beforeFetchSessionsCounter, 1)
	defer mm_atomic.AddUint64(&mmFetchSessions.afterFetchSessionsCounter, 1)

	if mmFetchSessions.inspectFuncFetchSessions != nil {
		mmFetchSessions.inspectFuncFetchSessions(ctx, chatID)
	}

	mm_params := &DatabaseMockFetchSessionsParams{ctx, chatID}

	// Record call args
	mmFetchSessions.FetchSessionsMock.mutex.Lock()
	mmFetchSessions.FetchSessionsMock.callArgs = append(mmFetchSessions.FetchSessionsMock.callArgs, mm_params)
	mmFetchSessions.FetchSessionsMock.mutex.Unlock()

	for _, e := range mmFetchSessions.FetchSessionsMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sa1, e.results.err
		}
	}

	if mmFetchSessions.FetchSessionsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFetchSessions.FetchSessionsMock.defaultExpectation.Counter, 1)
		mm_want := mmFetchSessions.FetchSessionsMock.defaultExpectation.params
		mm_got := DatabaseMockFetchSessionsParams{ctx, chatID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmFetchSessions.t.Errorf("DatabaseMock.FetchSessions got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmFetchSessions.FetchSessionsMock.defaultExpectation.results
		if mm_results == nil {
			mmFetchSessions.t.Fatal("No results are set for the DatabaseMock.FetchSessions")
		}
		return (*mm_results).sa1, (*mm_results).err
	}
	if mmFetchSessions.funcFetchSessions != nil {
		return mmFetchSessions.funcFetchSessions(ctx, chatID)
	}
	mmFetchSessions.t.Fatalf("Unexpected call to DatabaseMock.FetchSessions. %v %v", ctx, chatID)
	return
}

// FetchSessionsAfterCounter returns a count of finished DatabaseMock.FetchSessions invocations
func (mmFetchSessions *DatabaseMock) FetchSessionsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFetchSessions.afterFetchSessionsCounter)
}

// FetchSessionsBeforeCounter returns a count of DatabaseMock.FetchSessions invocations
func (mmFetchSessions *DatabaseMock) FetchSessionsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFetchSessions.beforeFetchSessionsCounter)
}

// Calls returns a list of arguments used in each call to DatabaseMock.FetchSessions.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmFetchSessions *mDatabaseMockFetchSessions) Calls() []*DatabaseMockFetchSessionsParams {
	mmFetchSessions.mutex.RLock()

	argCopy := make([]*DatabaseMockFetchSessionsParams, len(mmFetchSessions.callArgs))
	copy(argCopy, mmFetchSessions.callArgs)

	mmFetchSessions.mutex.RUnlock()

	return argCopy
}

// MinimockFetchSessionsDone returns true if the count of the FetchSessions invocations corresponds
// the number of defined expectations
func (m *DatabaseMock) MinimockFetchSessionsDone() bool {
	for _, e := range m.FetchSessionsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FetchSessionsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFetchSessionsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFetchSessions != nil && mm_atomic.LoadUint64(&m.afterFetchSessionsCounter) < 1 {
		return false
	}
	return true
}

// MinimockFetchSessionsInspect logs each unmet expectation
func (m *DatabaseMock) MinimockFetchSessionsInspect() {
	for _, e := range m.FetchSessionsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DatabaseMock.FetchSessions with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FetchSessionsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFetchSessionsCounter) < 1 {
		if m.FetchSessionsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to DatabaseMock.FetchSessions")
		} else {
			m.t.Errorf("Expected call to DatabaseMock.FetchSessions with params: %#v", *m.FetchSessionsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFetchSessions != nil && mm_atomic.LoadUint64(&m.afterFetchSessionsCounter) < 1 {
		m.t.Error("Expected call to DatabaseMock.FetchSessions")
	}
}

type mDatabaseMockFinishSession struct {
	mock               *DatabaseMock
	defaultExpectation *DatabaseMockFinishSessionExpectation
	expectations       []*DatabaseMockFinishSessionExpectation

	callArgs []*DatabaseMockFinishSessionParams
	mutex    sync.RWMutex
}

// DatabaseMockFinishSessionExpectation specifies expectation struct of the Database.FinishSession
type DatabaseMockFinishSessionExpectation struct {
	mock    *DatabaseMock
	params  *DatabaseMockFinishSessionParams
	results *DatabaseMockFinishSessionResults
	Counter uint64
}

// DatabaseMockFinishSessionParams contains parameters of the Database.FinishSession
type DatabaseMockFinishSessionParams struct {
	ctx    context.Context
	chatID int64
}

// DatabaseMockFinishSessionResults contains results of the Database.FinishSession
type DatabaseMockFinishSessionResults struct {
	err error
}

// Expect sets up expected params for Database.FinishSession
func (mmFinishSession *mDatabaseMockFinishSession) Expect(ctx context.Context, chatID int64) *mDatabaseMockFinishSession {
	if mmFinishSession.mock.funcFinishSession != nil {
		mmFinishSession.mock.t.Fatalf("DatabaseMock.FinishSession mock is already set by Set")
	}

	if mmFinishSession.defaultExpectation == nil {
		mmFinishSession.defaultExpectation = &DatabaseMockFinishSessionExpectation{}
	}

	mmFinishSession.defaultExpectation.params = &DatabaseMockFinishSessionParams{ctx, chatID}
	for _, e := range mmFinishSession.expectations {
		if minimock.Equal(e.params, mmFinishSession.defaultExpectation.params) {
			mmFinishSession.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmFinishSession.defaultExpectation.params)
		}
	}

	return mmFinishSession
}

// Inspect accepts an inspector function that has same arguments as the Database.FinishSession
func (mmFinishSession *mDatabaseMockFinishSession) Inspect(f func(ctx context.Context, chatID int64)) *mDatabaseMockFinishSession {
	if mmFinishSession.mock.inspectFuncFinishSession != nil {
		mmFinishSession.mock.t.Fatalf("Inspect function is already set for DatabaseMock.FinishSession")
	}

	mmFinishSession.mock.inspectFuncFinishSession = f

	return mmFinishSession
}

// Return sets up results that will be returned by Database.FinishSession
func (mmFinishSession *mDatabaseMockFinishSession) Return(err error) *DatabaseMock {
	if mmFinishSession.mock.funcFinishSession != nil {
		mmFinishSession.mock.t.Fatalf("DatabaseMock.FinishSession mock is already set by Set")
	}

	if mmFinishSession.defaultExpectation == nil {
		mmFinishSession.defaultExpectation = &DatabaseMockFinishSessionExpectation{mock: mmFinishSession.mock}
	}
	mmFinishSession.defaultExpectation.results = &DatabaseMockFinishSessionResults{err}
	return mmFinishSession.mock
}

//Set uses given function f to mock the Database.FinishSession method
func (mmFinishSession *mDatabaseMockFinishSession) Set(f func(ctx context.Context, chatID int64) (err error)) *DatabaseMock {
	if mmFinishSession.defaultExpectation != nil {
		mmFinishSession.mock.t.Fatalf("Default expectation is already set for the Database.FinishSession method")
	}

	if len(mmFinishSession.expectations) > 0 {
		mmFinishSession.mock.t.Fatalf("Some expectations are already set for the Database.FinishSession method")
	}

	mmFinishSession.mock.funcFinishSession = f
	return mmFinishSession.mock
}

// When sets expectation for the Database.FinishSession which will trigger the result defined by the following
// Then helper
func (mmFinishSession *mDatabaseMockFinishSession) When(ctx context.Context, chatID int64) *DatabaseMockFinishSessionExpectation {
	if mmFinishSession.mock.funcFinishSession != nil {
		mmFinishSession.mock.t.Fatalf("DatabaseMock.FinishSession mock is already set by Set")
	}

	expectation := &DatabaseMockFinishSessionExpectation{
		mock:   mmFinishSession.mock,
		params: &DatabaseMockFinishSessionParams{ctx, chatID},
	}
	mmFinishSession.expectations = append(mmFinishSession.expectations, expectation)
	return expectation
}

// Then sets up Database.FinishSession return parameters for the expectation previously defined by the When method
func (e *DatabaseMockFinishSessionExpectation) Then(err error) *DatabaseMock {
	e.results = &DatabaseMockFinishSessionResults{err}
	return e.mock
}

// FinishSession implements Database
func (mmFinishSession *DatabaseMock) FinishSession(ctx context.Context, chatID int64) (err error) {
	mm_atomic.AddUint64(&mmFinishSession.beforeFinishSessionCounter, 1)
	defer mm_atomic.AddUint64(&mmFinishSession.afterFinishSessionCounter, 1)

	if mmFinishSession.inspectFuncFinishSession != nil {
		mmFinishSession.inspectFuncFinishSession(ctx, chatID)
	}

	mm_params := &DatabaseMockFinishSessionParams{ctx, chatID}

	// Record call args
	mmFinishSession.FinishSessionMock.mutex.Lock()
	mmFinishSession.FinishSessionMock.callArgs = append(mmFinishSession.FinishSessionMock.callArgs, mm_params)
	mmFinishSession.FinishSessionMock.mutex.Unlock()

	for _, e := range mmFinishSession.FinishSessionMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmFinishSession.FinishSessionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFinishSession.FinishSessionMock.defaultExpectation.Counter, 1)
		mm_want := mmFinishSession.FinishSessionMock.defaultExpectation.params
		mm_got := DatabaseMockFinishSessionParams{ctx, chatID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmFinishSession.t.Errorf("DatabaseMock.FinishSession got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmFinishSession.FinishSessionMock.defaultExpectation.results
		if mm_results == nil {
			mmFinishSession.t.Fatal("No results are set for the DatabaseMock.FinishSession")
		}
		return (*mm_results).err
	}
	if mmFinishSession.funcFinishSession != nil {
		return mmFinishSession.funcFinishSession(ctx, chatID)
	}
	mmFinishSession.t.Fatalf("Unexpected call to DatabaseMock.FinishSession. %v %v", ctx, chatID)
	return
}

// FinishSessionAfterCounter returns a count of finished DatabaseMock.FinishSession invocations
func (mmFinishSession *DatabaseMock) FinishSessionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFinishSession.afterFinishSessionCounter)
}

// FinishSessionBeforeCounter returns a count of DatabaseMock.FinishSession invocations
func (mmFinishSession *DatabaseMock) FinishSessionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFinishSession.beforeFinishSessionCounter)
}

// Calls returns a list of arguments used in each call to DatabaseMock.FinishSession.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmFinishSession *mDatabaseMockFinishSession) Calls() []*DatabaseMockFinishSessionParams {
	mmFinishSession.mutex.RLock()

	argCopy := make([]*DatabaseMockFinishSessionParams, len(mmFinishSession.callArgs))
	copy(argCopy, mmFinishSession.callArgs)

	mmFinishSession.mutex.RUnlock()

	return argCopy
}

// MinimockFinishSessionDone returns true if the count of the FinishSession invocations corresponds
// the number of defined expectations
func (m *DatabaseMock) MinimockFinishSessionDone() bool {
	for _, e := range m.FinishSessionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FinishSessionMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFinishSessionCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFinishSession != nil && mm_atomic.LoadUint64(&m.afterFinishSessionCounter) < 1 {
		return false
	}
	return true
}

// MinimockFinishSessionInspect logs each unmet expectation
func (m *DatabaseMock) MinimockFinishSessionInspect() {
	for _, e := range m.FinishSessionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DatabaseMock.FinishSession with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FinishSessionMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFinishSessionCounter) < 1 {
		if m.FinishSessionMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to DatabaseMock.FinishSession")
		} else {
			m.t.Errorf("Expected call to DatabaseMock.FinishSession with params: %#v", *m.FinishSessionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFinishSession != nil && mm_atomic.LoadUint64(&m.afterFinishSessionCounter) < 1 {
		m.t.Error("Expected call to DatabaseMock.FinishSession")
	}
}

type mDatabaseMockIsCached struct {
	mock               *DatabaseMock
	defaultExpectation *DatabaseMockIsCachedExpectation
	expectations       []*DatabaseMockIsCachedExpectation

	callArgs []*DatabaseMockIsCachedParams
	mutex    sync.RWMutex
}

// DatabaseMockIsCachedExpectation specifies expectation struct of the Database.IsCached
type DatabaseMockIsCachedExpectation struct {
	mock    *DatabaseMock
	params  *DatabaseMockIsCachedParams
	results *DatabaseMockIsCachedResults
	Counter uint64
}

// DatabaseMockIsCachedParams contains parameters of the Database.IsCached
type DatabaseMockIsCachedParams struct {
	ctx            context.Context
	tournamentName string
}

// DatabaseMockIsCachedResults contains results of the Database.IsCached
type DatabaseMockIsCachedResults struct {
	cashed       bool
	tournamentID int64
	err          error
}

// Expect sets up expected params for Database.IsCached
func (mmIsCached *mDatabaseMockIsCached) Expect(ctx context.Context, tournamentName string) *mDatabaseMockIsCached {
	if mmIsCached.mock.funcIsCached != nil {
		mmIsCached.mock.t.Fatalf("DatabaseMock.IsCached mock is already set by Set")
	}

	if mmIsCached.defaultExpectation == nil {
		mmIsCached.defaultExpectation = &DatabaseMockIsCachedExpectation{}
	}

	mmIsCached.defaultExpectation.params = &DatabaseMockIsCachedParams{ctx, tournamentName}
	for _, e := range mmIsCached.expectations {
		if minimock.Equal(e.params, mmIsCached.defaultExpectation.params) {
			mmIsCached.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmIsCached.defaultExpectation.params)
		}
	}

	return mmIsCached
}

// Inspect accepts an inspector function that has same arguments as the Database.IsCached
func (mmIsCached *mDatabaseMockIsCached) Inspect(f func(ctx context.Context, tournamentName string)) *mDatabaseMockIsCached {
	if mmIsCached.mock.inspectFuncIsCached != nil {
		mmIsCached.mock.t.Fatalf("Inspect function is already set for DatabaseMock.IsCached")
	}

	mmIsCached.mock.inspectFuncIsCached = f

	return mmIsCached
}

// Return sets up results that will be returned by Database.IsCached
func (mmIsCached *mDatabaseMockIsCached) Return(cashed bool, tournamentID int64, err error) *DatabaseMock {
	if mmIsCached.mock.funcIsCached != nil {
		mmIsCached.mock.t.Fatalf("DatabaseMock.IsCached mock is already set by Set")
	}

	if mmIsCached.defaultExpectation == nil {
		mmIsCached.defaultExpectation = &DatabaseMockIsCachedExpectation{mock: mmIsCached.mock}
	}
	mmIsCached.defaultExpectation.results = &DatabaseMockIsCachedResults{cashed, tournamentID, err}
	return mmIsCached.mock
}

//Set uses given function f to mock the Database.IsCached method
func (mmIsCached *mDatabaseMockIsCached) Set(f func(ctx context.Context, tournamentName string) (cashed bool, tournamentID int64, err error)) *DatabaseMock {
	if mmIsCached.defaultExpectation != nil {
		mmIsCached.mock.t.Fatalf("Default expectation is already set for the Database.IsCached method")
	}

	if len(mmIsCached.expectations) > 0 {
		mmIsCached.mock.t.Fatalf("Some expectations are already set for the Database.IsCached method")
	}

	mmIsCached.mock.funcIsCached = f
	return mmIsCached.mock
}

// When sets expectation for the Database.IsCached which will trigger the result defined by the following
// Then helper
func (mmIsCached *mDatabaseMockIsCached) When(ctx context.Context, tournamentName string) *DatabaseMockIsCachedExpectation {
	if mmIsCached.mock.funcIsCached != nil {
		mmIsCached.mock.t.Fatalf("DatabaseMock.IsCached mock is already set by Set")
	}

	expectation := &DatabaseMockIsCachedExpectation{
		mock:   mmIsCached.mock,
		params: &DatabaseMockIsCachedParams{ctx, tournamentName},
	}
	mmIsCached.expectations = append(mmIsCached.expectations, expectation)
	return expectation
}

// Then sets up Database.IsCached return parameters for the expectation previously defined by the When method
func (e *DatabaseMockIsCachedExpectation) Then(cashed bool, tournamentID int64, err error) *DatabaseMock {
	e.results = &DatabaseMockIsCachedResults{cashed, tournamentID, err}
	return e.mock
}

// IsCached implements Database
func (mmIsCached *DatabaseMock) IsCached(ctx context.Context, tournamentName string) (cashed bool, tournamentID int64, err error) {
	mm_atomic.AddUint64(&mmIsCached.beforeIsCachedCounter, 1)
	defer mm_atomic.AddUint64(&mmIsCached.afterIsCachedCounter, 1)

	if mmIsCached.inspectFuncIsCached != nil {
		mmIsCached.inspectFuncIsCached(ctx, tournamentName)
	}

	mm_params := &DatabaseMockIsCachedParams{ctx, tournamentName}

	// Record call args
	mmIsCached.IsCachedMock.mutex.Lock()
	mmIsCached.IsCachedMock.callArgs = append(mmIsCached.IsCachedMock.callArgs, mm_params)
	mmIsCached.IsCachedMock.mutex.Unlock()

	for _, e := range mmIsCached.IsCachedMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cashed, e.results.tournamentID, e.results.err
		}
	}

	if mmIsCached.IsCachedMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmIsCached.IsCachedMock.defaultExpectation.Counter, 1)
		mm_want := mmIsCached.IsCachedMock.defaultExpectation.params
		mm_got := DatabaseMockIsCachedParams{ctx, tournamentName}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmIsCached.t.Errorf("DatabaseMock.IsCached got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmIsCached.IsCachedMock.defaultExpectation.results
		if mm_results == nil {
			mmIsCached.t.Fatal("No results are set for the DatabaseMock.IsCached")
		}
		return (*mm_results).cashed, (*mm_results).tournamentID, (*mm_results).err
	}
	if mmIsCached.funcIsCached != nil {
		return mmIsCached.funcIsCached(ctx, tournamentName)
	}
	mmIsCached.t.Fatalf("Unexpected call to DatabaseMock.IsCached. %v %v", ctx, tournamentName)
	return
}

// IsCachedAfterCounter returns a count of finished DatabaseMock.IsCached invocations
func (mmIsCached *DatabaseMock) IsCachedAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsCached.afterIsCachedCounter)
}

// IsCachedBeforeCounter returns a count of DatabaseMock.IsCached invocations
func (mmIsCached *DatabaseMock) IsCachedBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsCached.beforeIsCachedCounter)
}

// Calls returns a list of arguments used in each call to DatabaseMock.IsCached.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmIsCached *mDatabaseMockIsCached) Calls() []*DatabaseMockIsCachedParams {
	mmIsCached.mutex.RLock()

	argCopy := make([]*DatabaseMockIsCachedParams, len(mmIsCached.callArgs))
	copy(argCopy, mmIsCached.callArgs)

	mmIsCached.mutex.RUnlock()

	return argCopy
}

// MinimockIsCachedDone returns true if the count of the IsCached invocations corresponds
// the number of defined expectations
func (m *DatabaseMock) MinimockIsCachedDone() bool {
	for _, e := range m.IsCachedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IsCachedMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIsCachedCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsCached != nil && mm_atomic.LoadUint64(&m.afterIsCachedCounter) < 1 {
		return false
	}
	return true
}

// MinimockIsCachedInspect logs each unmet expectation
func (m *DatabaseMock) MinimockIsCachedInspect() {
	for _, e := range m.IsCachedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DatabaseMock.IsCached with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IsCachedMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIsCachedCounter) < 1 {
		if m.IsCachedMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to DatabaseMock.IsCached")
		} else {
			m.t.Errorf("Expected call to DatabaseMock.IsCached with params: %#v", *m.IsCachedMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsCached != nil && mm_atomic.LoadUint64(&m.afterIsCachedCounter) < 1 {
		m.t.Error("Expected call to DatabaseMock.IsCached")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *DatabaseMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockAddScoreInspect()

		m.MinimockAddSessionInspect()

		m.MinimockAddTournamentInspect()

		m.MinimockFetchQuestionInspect()

		m.MinimockFetchQuestionsInspect()

		m.MinimockFetchScoreInspect()

		m.MinimockFetchSessionsInspect()

		m.MinimockFinishSessionInspect()

		m.MinimockIsCachedInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *DatabaseMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *DatabaseMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddScoreDone() &&
		m.MinimockAddSessionDone() &&
		m.MinimockAddTournamentDone() &&
		m.MinimockFetchQuestionDone() &&
		m.MinimockFetchQuestionsDone() &&
		m.MinimockFetchScoreDone() &&
		m.MinimockFetchSessionsDone() &&
		m.MinimockFinishSessionDone() &&
		m.MinimockIsCachedDone()
}
